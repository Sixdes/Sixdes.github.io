<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[OpenCV_python 使用]]></title>
      <url>http://yoursite.com/2017/12/22/OpenCV_python%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>python-OpenCV</p>
<a id="more"></a>
<h1 id="Python-OpenCV"><a href="#Python-OpenCV" class="headerlink" title="Python - OpenCV"></a>Python - OpenCV</h1><p>介绍和深度学习数据处理阶段最相关的基础使用，并完成4个有趣实用的小例子：</p>
<ul>
<li>延时摄影小程序</li>
<li>视频中截屏采样的小程序</li>
<li>图片数据增加（data augmentation）的小工具</li>
<li>物体检测框标注小工具</li>
</ul>
<h2 id="OpenCV-简介"><a href="#OpenCV-简介" class="headerlink" title="OpenCV 简介"></a>OpenCV 简介</h2><p>OpenCV是计算机视觉领域应用最广泛的开源工具包，基于C/C++，支持Linux/Windows/MacOS/Android/iOS，并提供了Python，Matlab和Java等语言的接口.</p>
<h3 id="OpenCV的结构"><a href="#OpenCV的结构" class="headerlink" title="OpenCV的结构"></a>OpenCV的结构</h3><blockquote>
<p>和Python一样，当前的OpenCV也有两个大版本，OpenCV2和OpenCV3。相比OpenCV2，OpenCV3提供了更强的功能和更多方便的特性。不过考虑到和深度学习框架的兼容性，以及上手安装的难度，这部分先以2为主进行介绍。从使用的角度来看，和OpenCV2相比，OpenCV3的主要变化是更多的功能和更细化的模块划分。</p>
</blockquote>
<p>根据功能和需求的不同，OpenCV中的函数接口大体可以分为如下部分：</p>
<ul>
<li>core：核心模块，主要包含了OpenCV中最基本的结构（矩阵，点线和形状等），以及相关的基础运算/操作。</li>
<li>imgproc：图像处理模块，包含和图像相关的基础功能（滤波，梯度，改变大小等），以及一些衍生的高级功能（图像分割，直方图，形态分析和边缘/直线提取等). </li>
<li>highgui：提供了用户界面和文件读取的基本函数，比如图像显示窗口的生成和控制，图像/视频文件的IO等。</li>
</ul>
<p>如果不考虑视频应用，以上三个就是最核心和常用的模块了. </p>
<p>针对<strong>视频和一些特别的视觉应用</strong>，OpenCV也提供了强劲的支持：</p>
<ul>
<li>video：用于视频分析的常用功能，比如光流法（Optical Flow）和目标跟踪等。</li>
<li>calib3d：三维重建，立体视觉和相机标定等的相关功能。</li>
<li>features2d：二维特征相关的功能，主要是一些不受专利保护的，商业友好的特征点检测和匹配等功能，比如ORB特征。</li>
<li>object：目标检测模块，包含级联分类和Latent SVM</li>
<li>ml：机器学习算法模块，包含一些视觉中最常用的传统机器学习算法。</li>
<li>flann：最近邻算法库，Fast Library for Approximate Nearest Neighbors，用于在多维空间进行聚类和检索，经常和关键点匹配搭配使用。</li>
<li>gpu：包含了一些gpu加速的接口，底层的加速是CUDA实现。</li>
<li>photo：计算摄像学（Computational Photography）相关的接口，当然这只是个名字，其实只有图像修复和降噪而已。</li>
<li>stitching：图像拼接模块，有了它可以自己生成全景照片。</li>
<li>nonfree：受到专利保护的一些算法，其实就是SIFT和SURF。</li>
<li>contrib：一些实验性质的算法，考虑在未来版本中加入的。</li>
<li>legacy：字面是遗产，意思就是废弃的一些接口，保留是考虑到向下兼容。</li>
<li>ocl：利用OpenCL并行加速的一些接口。</li>
<li>superres：超分辨率模块，其实就是BTV-L1（Biliteral Total Variation – L1 regularization）算法</li>
<li>viz：基础的3D渲染模块，其实底层就是著名的3D工具包VTK（Visualization Toolkit）。</li>
</ul>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>图像就是一个矩阵，在OpenCV for Python中，图像就是NumPy中的数组, 图像使用NumPy数组的属性来表示图像的尺寸和通道信息</p>
<h5 id="读取图像"><a href="#读取图像" class="headerlink" title="读取图像"></a>读取图像</h5><p>读图像用<code>cv2.imread()</code>，可以按照不同模式读取，一般最常用到的是读取单通道灰度图，或者直接默认读取多通道。存图像用<code>cv2.imwrite()</code>，注意存的时候是没有单通道这一说的, 根据保存文件名的后缀和当前的array维度，OpenCV自动判断存的通道，另外压缩格式还可以指定存储质量.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -----------------------------</span></div><div class="line"><span class="comment"># 读取图像</span></div><div class="line"><span class="comment"># -----------------------------</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> cv2</div><div class="line"></div><div class="line">img = cv2.imread(<span class="string">'little_white_dog.jpeg'</span>)</div><div class="line">cv2.namedWindow(<span class="string">'Image'</span>)</div><div class="line">cv2.imshow(<span class="string">'Image'</span>, img)</div><div class="line">cv2.waitKey(<span class="number">0</span>)</div><div class="line">cv2.destroyAllWindows()</div><div class="line">print(img.shape)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">img = cv2.imread(<span class="string">'figure.jpg'</span>)</div><div class="line">px = img[<span class="number">100</span>,<span class="number">100</span>] </div><div class="line"><span class="comment"># [128 122 153]</span></div><div class="line">print( px)  </div><div class="line">blue = img[<span class="number">100</span>,<span class="number">100</span>,<span class="number">0</span>]  </div><div class="line">print(blue)</div><div class="line"></div><div class="line"><span class="comment"># 以上这种读取像素值的方式非常缓慢。推荐使用Numpy的函数——array.item()和array.itemset()来访问</span></div><div class="line"><span class="comment"># accessing red value  </span></div><div class="line">red = img.item(<span class="number">100</span>, <span class="number">100</span>, <span class="number">2</span>)</div><div class="line">print(red)</div><div class="line"></div><div class="line"><span class="comment"># modifying RED value  </span></div><div class="line">img.itemset((<span class="number">100</span>,<span class="number">100</span>,<span class="number">2</span>), <span class="number">10</span>)</div><div class="line">img.item(<span class="number">100</span>, <span class="number">100</span>, <span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment"># 获取图像的属性——行数、列数、通道数、图像的数据类型以及像素点的数量等</span></div><div class="line">img.shape</div><div class="line"><span class="comment"># 获得像素点的数量</span></div><div class="line">img.size</div><div class="line">img.dtype</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">color_img = cv2.imread(<span class="string">'test_400x600.jpeg'</span>)</div><div class="line">print(color_img.shape)</div><div class="line"></div><div class="line"><span class="comment"># 直接读取单通道</span></div><div class="line">gray_img = cv2.imread(<span class="string">'test_400x600.jpeg'</span>, cv2.IMREAD_GRAYSCALE)</div><div class="line">print(gray_img.shape)</div><div class="line"></div><div class="line"><span class="comment"># 把单通道图片保存后，再读取，仍然是3通道，相当于把单通道值复制到3个通道保存</span></div><div class="line">cv2.imwrite(<span class="string">'test_grayscale.jpeg'</span>, gray_img)</div><div class="line">reload_grascale = cv2.imread(<span class="string">'test_grayscale.jpeg'</span>)</div><div class="line">print(reload_grascale.shape)</div><div class="line"></div><div class="line"><span class="comment"># cv2.IMWRITE_JPEG_QUALITY指定jpg质量，范围0到100，默认95，越高画质越好，文件越大</span></div><div class="line">cv2.imwrite(<span class="string">'test_imwrite.jpeg'</span>, color_img, (int(cv2.IMWRITE_JPEG_QUALITY), <span class="number">80</span>))</div><div class="line"></div><div class="line">cv2.imwrite(<span class="string">'test_imwrite.png'</span>, color_img, (int(cv2.IMWRITE_PNG_COMPRESSION), <span class="number">5</span>))</div></pre></td></tr></table></figure>
<h5 id="创建-复制图像"><a href="#创建-复制图像" class="headerlink" title="创建/复制图像"></a>创建/复制图像</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -----------------------------</span></div><div class="line"><span class="comment"># 创建/复制图像</span></div><div class="line"><span class="comment"># 图像就是一个矩阵，在OpenCV for Python中，图像就是NumPy中的数组</span></div><div class="line"><span class="comment"># 如果要创建图像，需要使用numpy的函数, 图像使用NumPy数组的属性来表示图像的尺寸和通道信息</span></div><div class="line"><span class="comment"># -----------------------------</span></div><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">img = cv2.imread(<span class="string">'little_white_dog.jpeg'</span>)</div><div class="line">emptyImage = np.zeros(img.shape, np.uint8)</div><div class="line"></div><div class="line">emptyImage2 = img.copy()</div><div class="line"></div><div class="line">emptyImage3 = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</div><div class="line"><span class="comment"># emptyImage3[...] = 0</span></div><div class="line"></div><div class="line">cv2.imshow(<span class="string">'EmptyImage'</span>, emptyImage)</div><div class="line">cv2.imshow(<span class="string">'Image'</span>, img)</div><div class="line">cv2.imshow(<span class="string">'EmptyImage2'</span>, emptyImage2)</div><div class="line">cv2.imshow(<span class="string">'EmptyImage3'</span>, emptyImage3)</div><div class="line"></div><div class="line"><span class="comment"># 第三个参数针对特定的格式： 对于JPEG，其表示的是图像的质量，</span></div><div class="line"><span class="comment"># 用0-100的整数表示，默认为95。 注意，cv2.IMWRITE_JPEG_QUALITY类型为Long，必须转换成int。下面是以不同质量存储的两幅图：</span></div><div class="line"></div><div class="line">cv2.imwrite(<span class="string">'little_white_dog2.jpg'</span>, img, [int(cv2.IMWRITE_JPEG_QUALITY), <span class="number">5</span>])</div><div class="line">cv2.imwrite(<span class="string">'little_white_dog3.jpg'</span>, img, [int(cv2.IMWRITE_JPEG_QUALITY), <span class="number">100</span>])</div><div class="line"></div><div class="line"><span class="comment"># 对于PNG，第三个参数表示的是压缩级别。cv2.IMWRITE_PNG_COMPRESSION，从0到9,压缩级别越高，图像尺寸越小。默认级别为3：</span></div><div class="line"></div><div class="line">cv2.imwrite(<span class="string">'little_white_dog2.png'</span>, img, [int(cv2.IMWRITE_PNG_COMPRESSION), <span class="number">0</span>])</div><div class="line">cv2.imwrite(<span class="string">'little_white_dog3.png'</span>, img, [int(cv2.IMWRITE_PNG_COMPRESSION), <span class="number">9</span>])</div><div class="line"></div><div class="line">cv2.waitKey(<span class="number">0</span>)</div><div class="line">cv2.destroyAllWindows()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># numpy 全复制  不是镜像</span></div><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">img = cv2.imread(<span class="string">'little_white_dog.jpeg'</span>)</div><div class="line">c = np.zeros(img.shape, dtype=img.dtype)</div><div class="line">c[:, :, :] = img[:, :, :]</div><div class="line">c <span class="keyword">is</span> img  <span class="comment"># false</span></div><div class="line">c.base <span class="keyword">is</span> img  <span class="comment"># false</span></div></pre></td></tr></table></figure>
<h5 id="图像元素的访问"><a href="#图像元素的访问" class="headerlink" title="图像元素的访问"></a>图像元素的访问</h5><p><strong>与C++不同，在Python中灰度图的img.ndim = 2，而C++中灰度图图像的通道数img.channel() =1</strong></p>
<p>这里使用了numpy的随机数，Python自身也有一个随机数生成函数。这里只是一种习惯，np.random模块中拥有更多的方法，而Python自带的random只是一个轻量级的模块。不过需要注意的是np.random.seed()不是线程安全的，而<strong>Python自带的random.seed()是线程安全</strong>的。如果使用随机数时需要用到多线程，建议使用Python自带的random()和random.seed()，或者构建一个本地的np.random.Random类的实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -----------------------------</span></div><div class="line"><span class="comment"># 图像元素的访问</span></div><div class="line"><span class="comment"># 像素的访问和访问numpy中ndarray的方法完全一样</span></div><div class="line"><span class="comment"># 下面通过对图像添加人工的椒盐现象来进一步说明OpenCV Python中需要注意的一些问题</span></div><div class="line"><span class="comment"># -----------------------------</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">salt</span><span class="params">(img, n)</span>:</span></div><div class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</div><div class="line">        j = int(np.random.random() * img.shape[<span class="number">0</span>])</div><div class="line">        i = int(np.random.random() * img.shape[<span class="number">1</span>])</div><div class="line">        <span class="keyword">if</span> img.ndim == <span class="number">2</span>:</div><div class="line">            img[j, i] = <span class="number">255</span></div><div class="line">        <span class="keyword">elif</span> img.ndim ==<span class="number">3</span>:</div><div class="line">            img[j, i, <span class="number">0</span>] = <span class="number">255</span></div><div class="line">            img[j, i, <span class="number">1</span>] = <span class="number">255</span></div><div class="line">            img[j, i, <span class="number">2</span>] = <span class="number">255</span></div><div class="line">    <span class="keyword">return</span> img</div><div class="line">        </div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    img = cv2.imread(<span class="string">'iPhone.png'</span>)</div><div class="line">    saltImage = salt(img, <span class="number">500</span>)</div><div class="line">    cv2.imshow(<span class="string">'Salt'</span>, saltImage)</div><div class="line">    cv2.waitKey(<span class="number">0</span>)</div><div class="line">    cv2.destoryAllWindows()</div></pre></td></tr></table></figure>
<h5 id="缩放，裁剪和补边"><a href="#缩放，裁剪和补边" class="headerlink" title="缩放，裁剪和补边"></a>缩放，裁剪和补边</h5><p>缩放通过<code>cv2.resize()</code>实现(<strong>指定大小的格式是(宽度,高度)</strong>)，裁剪则是利用array自身的下标截取实现，此外OpenCV还可以给图像补边，这样能对一幅图像的形状和感兴趣区域实现各种操作。</p>
<p>下面的例子中读取一幅400×600分辨率的图片，并执行一些基础的操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># 读取一张600x375分辨率的图像</span></div><div class="line">img = cv2.imread(<span class="string">'figure.jpg'</span>)</div><div class="line"><span class="comment"># 缩放成200x200的方形图像</span></div><div class="line">img_200x200 = cv2.resize(img, (<span class="number">200</span>, <span class="number">200</span>))</div><div class="line"></div><div class="line"><span class="comment"># 不直接指定缩放后大小，通过fx和fy指定缩放比例，0.5则长宽都为原来一半</span></div><div class="line"><span class="comment"># 等效于img_200x300 = cv2.resize(img, (300, 200))，注意指定大小的格式是(宽度,高度)</span></div><div class="line"></div><div class="line"><span class="comment"># 插值方法默认是cv2.INTER_LINEAR，这里指定为最近邻插值</span></div><div class="line"><span class="comment"># fx、fy是沿x轴和y轴的缩放系数 和 dsize不能同时为0</span></div><div class="line"><span class="string">'''</span></div><div class="line">最优一个参数interpolation表示插值方式，有以下几种：</div><div class="line">INTER_NEAREST - 最近邻插值</div><div class="line">INTER_LINEAR - 线性插值（默认）</div><div class="line">INTER_AREA - 区域插值</div><div class="line">INTER_CUBIC - 三次样条插值</div><div class="line">INTER_LANCZOS4 - Lanczos插值</div><div class="line">'''</div><div class="line">img_200x300 = cv2.resize(img, (<span class="number">200</span>, <span class="number">300</span>), fx=<span class="number">0.5</span>, fy=<span class="number">0.5</span>, interpolation=cv2.INTER_NEAREST)</div><div class="line"></div><div class="line"><span class="comment"># 在上张图片的基础上，上下各贴50像素的黑边，生成300x300的图像</span></div><div class="line">img_300x300 = cv2.copyMakeBorder(img, <span class="number">50</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>, cv2.BORDER_CONSTANT, value=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</div><div class="line"></div><div class="line"><span class="comment"># 对照片中人脸的部分进行剪裁  高度区间和宽度区间  </span></div><div class="line"><span class="comment"># patch_tree = img[20:150, -300:-10]</span></div><div class="line">patch_tree = img[<span class="number">7</span>:<span class="number">150</span>, <span class="number">300</span>:<span class="number">450</span>]</div><div class="line"></div><div class="line">cv2.imwrite(<span class="string">'cropped_tree.jpg'</span>, patch_tree)</div><div class="line">cv2.imwrite(<span class="string">'resize_200x300.jpg'</span>, img_200x300)</div><div class="line">cv2.imwrite(<span class="string">'bordered_300x300.jpg'</span>, img_300x300)</div><div class="line">cv2.imwrite(<span class="string">'resize_200x200.jpg'</span>, img_200x200)</div></pre></td></tr></table></figure>
<p><strong>补边:</strong></p>
<p><img src="/images/OpenCV_python使用/bordered_300x300.jpg" alt="bordered_300x300"></p>
<p><strong>裁剪:</strong></p>
<p><img src="/images/OpenCV_python使用/cropped_tree.jpg" alt="cropped_tree"></p>
<h5 id="色调，明暗，直方图和Gamma曲线"><a href="#色调，明暗，直方图和Gamma曲线" class="headerlink" title="色调，明暗，直方图和Gamma曲线"></a>色调，明暗，直方图和Gamma曲线</h5><p>除了区域，图像本身的属性操作也非常多，比如可以通过HSV空间对色调和明暗进行调节。(HSV分别是色调(Hue), 饱和度（Saturation）和明度（Value）。在HSV空间中进行调节就避免了直接在RGB空间中调节是还需要考虑三个通道的相关性. OpenCV中H的取值是[0, 180)，其他两个通道的取值都是[0, 256). </p>
<p>下面例子接着上面例子代码，通过HSV空间对图像进行调整：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cv2</div><div class="line"></div><div class="line">img = cv2.imread(<span class="string">'figure.jpg'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 通过cv2.cvtColor把图像从BGR转换到HSV</span></div><div class="line">img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)</div><div class="line"></div><div class="line">turn_green = img_hsv.copy()</div><div class="line">colorless_hsv = img_hsv.copy()</div><div class="line">darker_hsv = img_hsv.copy()</div><div class="line"></div><div class="line"><span class="comment"># H空间中，绿色比黄色的值高一点，所以给每个像素+15，黄色的树叶就会变绿</span></div><div class="line">turn_green[:, :, <span class="number">0</span>] = (turn_green[:, :, <span class="number">0</span>]+<span class="number">15</span>) % <span class="number">180</span></div><div class="line">turn_green_img = cv2.cvtColor(turn_green, cv2.COLOR_HSV2BGR)</div><div class="line">cv2.imwrite(<span class="string">'trun_green.jpg'</span>, turn_green_img)</div><div class="line"></div><div class="line"><span class="comment"># 减小饱和度会让图像损失鲜艳，变得更灰</span></div><div class="line">colorless_hsv[:, :, <span class="number">1</span>] = <span class="number">0.5</span> * colorless_hsv[:, :, <span class="number">1</span>]</div><div class="line">colorless_img = cv2.cvtColor(colorless_hsv, cv2.COLOR_HSV2BGR)</div><div class="line">cv2.imwrite(<span class="string">'colorless.jpg'</span>, colorless_img)</div><div class="line"></div><div class="line"><span class="comment"># 减小明度为原来一半</span></div><div class="line">darker_hsv[:, :, <span class="number">2</span>] = <span class="number">0.5</span> * darker_hsv[:, :, <span class="number">2</span>]</div><div class="line">darker_img = cv2.cvtColor(darker_hsv, cv2.COLOR_HSV2BGR)</div><div class="line">cv2.imwrite(<span class="string">'darker.jpg'</span>, darker_img)</div></pre></td></tr></table></figure>
<ol>
<li><p>更改色调</p>
<p><img src="/images/OpenCV_python使用/trun_green.jpg" alt="trun_green"></p>
</li>
<li><p>更改饱和度</p>
<p><img src="/images/OpenCV_python使用/colorless.jpg" alt="colorless"></p>
</li>
<li><p>更改亮度</p>
<p><img src="/images/OpenCV_python使用/darker.jpg" alt="darker"></p>
</li>
</ol>
<p><strong>直方图</strong></p>
<p>无论是HSV还是RGB，我们都较难一眼就对像素中值的分布有细致的了解，这时候就需要直方图。如果直方图中的成分过于靠近0或者255，可能就出现了<strong>暗部细节不足或者亮部细节丢失</strong>的情况。</p>
<p>这个时候，一个常用方法是考虑用Gamma变换来提升暗部细节。Gamma变换是矫正相机直接成像和人眼感受图像差别的一种常用手段，</p>
<p>简单来说就是通过非线性变换让图像从对曝光强度的线性响应变得更接近人眼感受到的响应。</p>
<p><strong>矫正前:</strong></p>
<p><img src="/images/OpenCV_python使用/darker.jpg" alt="darker"></p>
<p><strong>矫正后:</strong></p>
<p><img src="/images/OpenCV_python使用/img_corrected.jpg" alt="img_corrected"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line">cv2.calcHist(images, channels, mask, histSize, ranges[, hist[, accumulate ]]) 返回hist</div><div class="line">其中第一个参数必须用方括号括起来。</div><div class="line">第二个参数是用于计算直方图的通道</div><div class="line">第三个参数是Mask，这里没有使用，所以用None。</div><div class="line">第四个参数是histSize，表示这个直方图分成多少份（即多少个直方柱）</div><div class="line">第五个参数是表示直方图中各个像素的值, [0.0, 256.0]表示直方图能表示像素值从0.0到256的像素。</div><div class="line">最后是两个可选参数，由于直方图作为函数结果返回了，所以第六个hist就没有意义了（待确定）</div><div class="line">最后一个accumulate是一个布尔值，用来表示直方图是否叠加。</div><div class="line">'''</div><div class="line">img = cv2.imread(<span class="string">'darker.jpg'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 直方图 &lt;class 'numpy.ndarray'&gt; (256, 1)</span></div><div class="line">hist_b = cv2.calcHist([img], [<span class="number">0</span>], <span class="keyword">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</div><div class="line">hist_g = cv2.calcHist([img], [<span class="number">1</span>], <span class="keyword">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</div><div class="line">hist_r = cv2.calcHist([img], [<span class="number">2</span>], <span class="keyword">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</div><div class="line"></div><div class="line"><span class="comment"># 定义Gamma矫正的函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gamma_trans</span><span class="params">(img, gamma)</span>:</span></div><div class="line">    <span class="comment"># 具体做法是先归一化到1，然后gamma作为指数值求出新的像素值再还原</span></div><div class="line">    gamma_table = [np.power(x/<span class="number">255.0</span>, gamma)*<span class="number">255.0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">256</span>)]</div><div class="line">    gamma_table = np.round(np.array(gamma_table)).astype(np.uint8)</div><div class="line">    </div><div class="line">     <span class="comment"># 实现这个映射用的是OpenCV的查找表函数</span></div><div class="line">    <span class="keyword">return</span> cv2.LUT(img, gamma_table)</div><div class="line"></div><div class="line"><span class="comment"># 执行Gamma矫正，小于1的值让暗部细节大量提升，同时亮部细节少量提升</span></div><div class="line">img_corrected = gamma_trans(img, <span class="number">0.5</span>)</div><div class="line">cv2.imwrite(<span class="string">'img_corrected.jpg'</span>,img_corrected)</div><div class="line"></div><div class="line"><span class="comment"># 分通道计算Gamma矫正后的直方图  256行一列</span></div><div class="line">hist_b_corrected = cv2.calcHist([img_corrected], [<span class="number">0</span>], <span class="keyword">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</div><div class="line">hist_g_corrected = cv2.calcHist([img_corrected], [<span class="number">1</span>], <span class="keyword">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</div><div class="line">hist_r_corrected = cv2.calcHist([img_corrected], [<span class="number">2</span>], <span class="keyword">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</div><div class="line"></div><div class="line"><span class="comment"># 这样就会变成一行</span></div><div class="line"><span class="comment"># -------------------------------</span></div><div class="line"><span class="comment"># print(hist_b_corrected.reshape(-1))</span></div><div class="line"></div><div class="line">fig = plt.figure(figsize=(<span class="number">12</span>, <span class="number">6</span>))</div><div class="line"></div><div class="line">pix_hists = [</div><div class="line">    [hist_b.reshape(<span class="number">-1</span>), hist_g.reshape(<span class="number">-1</span>), hist_r.reshape(<span class="number">-1</span>)],</div><div class="line">    [hist_b_corrected.reshape(<span class="number">-1</span>), hist_g_corrected.reshape(<span class="number">-1</span>), hist_r_corrected.reshape(<span class="number">-1</span>)]</div><div class="line">]</div><div class="line"></div><div class="line">pix_vals = range(<span class="number">256</span>)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">for</span> sub_plt, pix_hist <span class="keyword">in</span> zip([<span class="number">121</span>, <span class="number">122</span>], pix_hists):</div><div class="line">    ax = fig.add_subplot(sub_plt, projection=<span class="string">'3d'</span>)</div><div class="line">    <span class="keyword">for</span> c, z, channel_hist <span class="keyword">in</span> zip([<span class="string">'b'</span>, <span class="string">'g'</span>, <span class="string">'r'</span>], [<span class="number">20</span>, <span class="number">10</span>, <span class="number">0</span>], pix_hist):</div><div class="line">        cs = [c] * <span class="number">256</span></div><div class="line">        <span class="comment"># 传入的 XYZ应该是一维数组, 不能是二维, 应该是一行</span></div><div class="line">        ax.bar(pix_vals, channel_hist, zs=z, zdir=<span class="string">'y'</span>, color=cs, alpha=<span class="number">0.618</span>, edgecolor=<span class="string">'none'</span>, lw=<span class="number">0</span>)</div><div class="line"></div><div class="line">    ax.set_xlabel(<span class="string">'Pixel Values'</span>)</div><div class="line">    ax.set_xlim([<span class="number">0</span>, <span class="number">256</span>])</div><div class="line">    ax.set_ylabel(<span class="string">'Channels'</span>)</div><div class="line">    ax.set_zlabel(<span class="string">'Counts'</span>)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/images/OpenCV_python使用/output_14_0.png" alt="output_14_0"></p>
<p>接上图 可以看到，Gamma变换后的暗部细节比起原图清楚了很多，并且从直方图来看，像素值也从集中在0附近变得散开了一些。</p>
<h5 id="分离通道"><a href="#分离通道" class="headerlink" title="分离通道"></a>分离通道</h5><p>由于OpenCV Python和NumPy结合的很紧, 所以即可以使用OpenCV自带的split函数，也可以直接操作numpy数组来分离通道。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -----------------------------</span></div><div class="line"><span class="comment"># 分离、合并通道</span></div><div class="line"><span class="comment"># 即可以使用OpenCV自带的split函数，也可以直接操作numpy数组来分离通道。</span></div><div class="line"><span class="comment"># </span></div><div class="line"><span class="comment"># -----------------------------</span></div><div class="line"><span class="keyword">import</span> cv2</div><div class="line"></div><div class="line">img = cv2.imread(<span class="string">'little_white_dog.jpeg'</span>)</div><div class="line">b, g, r = cv2.split(img)</div><div class="line">cv2.imshow(<span class="string">'Blue'</span>, b)</div><div class="line">cv2.imshow(<span class="string">'Green'</span>, g)</div><div class="line">cv2.imshow(<span class="string">'Red'</span>, r)</div><div class="line"></div><div class="line">cv2.waitKey(<span class="number">0</span>)</div><div class="line">cv2.destroyAllWindows()  </div><div class="line"></div><div class="line"><span class="comment"># split返回RGB三个通道，如果只想返回其中一个通道, 最后的索引指出所需要的通道。</span></div><div class="line">b2 = cv2.split(img)[<span class="number">0</span>]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 也可以直接操作NumPy数组来达到这一目的：</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">img = cv2.imread(<span class="string">'little_white_dog.jpeg'</span>)</div><div class="line">b = np.zeros((img.shape[<span class="number">0</span>], img.shape[<span class="number">1</span>]), dtype=img.dtype)</div><div class="line">g = np.zeros((img.shape[<span class="number">0</span>], img.shape[<span class="number">1</span>]), dtype=img.dtype)</div><div class="line">r = np.zeros((img.shape[<span class="number">0</span>], img.shape[<span class="number">1</span>]), dtype=img.dtype)</div><div class="line"></div><div class="line">b[:, :] = img[:, :, <span class="number">0</span>]</div><div class="line">g[:, :] = img[:, :, <span class="number">1</span>]</div><div class="line">r[:, :] = img[:, :, <span class="number">2</span>]</div><div class="line"></div><div class="line">cv2.imshow(<span class="string">'Blue'</span>, b)</div><div class="line">cv2.imshow(<span class="string">'green'</span>, g)</div><div class="line">cv2.imshow(<span class="string">'red'</span>, r)</div><div class="line"></div><div class="line">cv2.waitKey(<span class="number">0</span>)</div><div class="line">cv2.destoryAllWindows()</div></pre></td></tr></table></figure>
<h5 id="通道合并"><a href="#通道合并" class="headerlink" title="通道合并"></a>通道合并</h5><p><strong>????????注意：这里只是演示，实际使用时请用OpenCV自带的merge函数！用NumPy组合的结果不能在OpenCV中其他函数使用，因为其组合方式与OpenCV自带的不一样，如下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">img = cv2.imread(<span class="string">'little_white_dog.jpeg'</span>)</div><div class="line">b = np.zeros((img.shape[<span class="number">0</span>], img.shape[<span class="number">1</span>]), dtype=img.dtype)</div><div class="line">g = np.zeros((img.shape[<span class="number">0</span>], img.shape[<span class="number">1</span>]), dtype=img.dtype)</div><div class="line">r = np.zeros((img.shape[<span class="number">0</span>], img.shape[<span class="number">1</span>]), dtype=img.dtype)</div><div class="line"></div><div class="line">b[:, :] = img[:, :, <span class="number">0</span>]</div><div class="line">g[:, :] = img[:, :, <span class="number">1</span>]</div><div class="line">r[:, :] = img[:, :, <span class="number">2</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># openCV 方法 merge</span></div><div class="line">merged = cv2.merge([b, g, r])</div><div class="line">print(<span class="string">'merge by opencv'</span>)</div><div class="line"><span class="comment"># 在每个维数上以字节计算的步长</span></div><div class="line">print(merged.strides)</div><div class="line"><span class="comment"># numpy 方法  dstack</span></div><div class="line">mergedByNp = np.dstack([b, g, r])</div><div class="line">print(<span class="string">'merge by numpy'</span>)</div><div class="line">print(mergedByNp.strides)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 关于stride</span></div><div class="line"><span class="comment"># 在每个维数上以字节计算的步长</span></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="comment"># a数组中每个元素都是NumPy中的整数类型，占8个字节，所以第一维中相邻元素之间的步长为8（个字节）。</span></div><div class="line">a = np.arange(<span class="number">6</span>)</div><div class="line"><span class="comment"># (8,)</span></div><div class="line">print(a.strides)</div><div class="line">print(a.dtype)  <span class="comment"># int64</span></div><div class="line"></div><div class="line"><span class="comment"># 从里面开始看，里面是一个4个元素的一维整数数组，所以步长应该为8。外面是一个含有3个元素，每个元素的长度是8×4=32。所以步长为32。</span></div><div class="line">b = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>, <span class="number">4</span>)</div><div class="line">b.strides</div><div class="line"></div><div class="line"><span class="comment"># (160, 40, 8)</span></div><div class="line">c = np.arange(<span class="number">60</span>).reshape(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment"># 三维, 行 , 列</span></div><div class="line">c.strides</div></pre></td></tr></table></figure>
<h2 id="Python-OpenCV基础"><a href="#Python-OpenCV基础" class="headerlink" title="Python-OpenCV基础"></a>Python-OpenCV基础</h2><h3 id="图像的表示"><a href="#图像的表示" class="headerlink" title="图像的表示"></a>图像的表示</h3><p>单通道的灰度图像在计算机中的表示，就是一个8位无符号整形的矩阵。</p>
<p><strong>在OpenCV中，默认的图像的表示确实反过来的，也就是BGR</strong>, 比如在Python中，图像都是用numpy的array表示，但是同样的array在OpenCV中的显示效果和matplotlib中的显示效果就会不一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">img = np.array([</div><div class="line">    [[<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>]],</div><div class="line">    [[<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>], [<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>], [<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>]],</div><div class="line">    [[<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>], [<span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]],</div><div class="line">], dtype=np.uint8)</div><div class="line"></div><div class="line">plt.figure(<span class="string">'matplotlib &amp; OpenCV'</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>))</div><div class="line"><span class="comment"># 用matplotlib存储</span></div><div class="line">plt.imsave(<span class="string">'img_pyplot.jpg'</span>, img)</div><div class="line"></div><div class="line"><span class="comment"># 用OpenCV存储</span></div><div class="line">cv2.imwrite(<span class="string">'img_cv2.jpg'</span>, img)</div></pre></td></tr></table></figure>
<p><strong>不管是RGB还是BGR，都是高度×宽度×通道数，H×W×C的表达方式，而在深度学习中，因为要对不同通道应用卷积，所以用的是另一种方式：C×H×W，就是把每个通道都单独表达成一个二维矩阵.</strong><br>np.reshape() 😂 好像就是 CHW (不知道能否这么表述)</p>
<p><strong>像素点太小了, 截图展示</strong></p>
<p><strong>用matplotlib存储:</strong></p>
<p><img src="/images/OpenCV_python使用/img_pyplot截图.png" alt="img_pyplot截图"></p>
<p><strong>用OpenCV存储:</strong></p>
<p><img src="/images/OpenCV_python使用/.png" alt="img_cv2截图"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[matplotlib 使用]]></title>
      <url>http://yoursite.com/2017/12/22/matplotlib%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>python-matplotlib</p>
<a id="more"></a>
<h1 id="python-matplotlib-jupyter"><a href="#python-matplotlib-jupyter" class="headerlink" title="python matplotlib jupyter"></a>python matplotlib jupyter</h1><p>matplotlib 是 python 的 著名数据可视化工具包</p>
<h2 id="2D图表"><a href="#2D图表" class="headerlink" title="2D图表"></a>2D图表</h2><p>Matplotlib中最基础的模块是pyplot。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%matplotlib inline</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 有一组数据，还有一个拟合模型，通过下面的代码图来可视化</span></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="comment"># 通过rcParams设置全局横纵轴字体大小</span></div><div class="line">mpl.rcParams[<span class="string">'xtick.labelsize'</span>] = <span class="number">24</span></div><div class="line">mpl.rcParams[<span class="string">'ytick.labelsize'</span>] = <span class="number">24</span></div><div class="line"></div><div class="line">np.random.seed(<span class="number">42</span>)</div><div class="line"><span class="comment"># x 轴的采样点</span></div><div class="line">x = np.linspace(<span class="number">0</span>, <span class="number">5</span>, <span class="number">100</span>)</div><div class="line"><span class="comment"># 通过下面曲线加上噪声生成数据，所以拟合模型就用y了……</span></div><div class="line">y = <span class="number">2</span>*np.sin(x) + <span class="number">0.3</span>*x**<span class="number">2</span></div><div class="line">y_data = y + np.random.normal(scale=<span class="number">0.3</span>, size=<span class="number">100</span>)</div><div class="line"></div><div class="line"><span class="comment"># figure() 指定图表名称</span></div><div class="line">plt.figure(<span class="string">'data'</span>)</div><div class="line"></div><div class="line"><span class="comment"># '.'标明画散点图，每个散点的形状是个圆</span></div><div class="line">plt.plot(x, y_data, <span class="string">'.'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 画模型的图，plot函数默认画连线图</span></div><div class="line">plt.figure(<span class="string">'model'</span>)</div><div class="line">plt.plot(x, y)</div><div class="line"></div><div class="line"><span class="comment"># 两个图画一起</span></div><div class="line">plt.figure(<span class="string">'data &amp; model'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 通过'k'指定线的颜色，lw指定线的宽度</span></div><div class="line"><span class="comment"># 第三个参数除了颜色也可以指定线形，比如'r--'表示红色虚线</span></div><div class="line"><span class="comment"># 更多属性可以参考官网：http://matplotlib.org/api/pyplot_api.html</span></div><div class="line">plt.plot(x, y, <span class="string">'k'</span>, lw=<span class="number">3</span>)</div><div class="line"></div><div class="line"><span class="comment"># scatter可以更容易地生成散点图</span></div><div class="line">plt.scatter(x, y_data)</div><div class="line"></div><div class="line"><span class="comment"># 将当前figure的图保存到文件result.png</span></div><div class="line">plt.savefig(<span class="string">'result.png'</span>)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/images/matplotlib使用/output_3_0.png" alt="output_3_0"></p>
<p><img src="/images/matplotlib使用/output_3_1.png" alt="output_3_0"></p>
<p><img src="/images/matplotlib使用/output_3_2.png" alt="output_3_2"></p>
<p>点和线图表只是最基本的用法，有的时候我们获取了分组数据要做对比，柱状或饼状类型的图</p>
<p>平时画图蹦出的一个窗口，这叫一个figure。Figure相当于一个大的画布，在每个figure中，又可以存在多个子图，这种子图叫做axes。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="comment"># 全都是设置字的大小</span></div><div class="line">mpl.rcParams[<span class="string">'axes.titlesize'</span>] = <span class="number">13</span></div><div class="line">mpl.rcParams[<span class="string">'xtick.labelsize'</span>] = <span class="number">10</span></div><div class="line">mpl.rcParams[<span class="string">'ytick.labelsize'</span>] = <span class="number">10</span></div><div class="line">mpl.rcParams[<span class="string">'axes.labelsize'</span>] = <span class="number">10</span></div><div class="line">mpl.rcParams[<span class="string">'xtick.major.size'</span>] = <span class="number">0</span></div><div class="line">mpl.rcParams[<span class="string">'ytick.major.size'</span>] = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="comment"># 包含了狗，猫和猎豹的最高奔跑速度，还有对应的可视化颜色</span></div><div class="line">speed_map = &#123;</div><div class="line">  <span class="string">'dog'</span>: (<span class="number">48</span>, <span class="string">'#7199cf'</span>),</div><div class="line">  <span class="string">'cat'</span>: (<span class="number">45</span>, <span class="string">'#4fc4aa'</span>),</div><div class="line">  <span class="string">'cheetah'</span>: (<span class="number">120</span>, <span class="string">'#e1a7a2'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 整体图的标题</span></div><div class="line">fig = plt.figure(<span class="string">'Bar chart &amp; Pie chart'</span>, figsize=(<span class="number">12</span>,<span class="number">6</span>))</div><div class="line"></div><div class="line"><span class="comment"># 在整张图上加入一个子图，121的意思是在一个1行2列的子图中的第一张</span></div><div class="line">ax = fig.add_subplot(<span class="number">121</span>)</div><div class="line">ax.set_title(<span class="string">'Running speed - bar chart'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 生成x轴每个元素的位置</span></div><div class="line">xticks = np.arange(<span class="number">3</span>)</div><div class="line"></div><div class="line"><span class="comment"># 定义柱状图每个柱的宽度</span></div><div class="line">bar_width = <span class="number">0.5</span></div><div class="line"></div><div class="line"><span class="comment"># 动物名称</span></div><div class="line">animals = speed_map.keys()</div><div class="line"></div><div class="line"><span class="comment"># 奔跑速度</span></div><div class="line">speeds = [x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> speed_map.values()]</div><div class="line"></div><div class="line"><span class="comment"># 对应颜色</span></div><div class="line">colors = [x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> speed_map.values()]</div><div class="line"></div><div class="line"><span class="comment"># 画柱状图，横轴是动物标签的位置，纵轴是速度，定义柱的宽度，同时设置柱的边缘为透明</span></div><div class="line">bars = ax.bar(xticks, speeds, width=bar_width, edgecolor=<span class="string">'none'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 设置y轴的标题</span></div><div class="line">ax.set_ylabel(<span class="string">'Speed(km/h)'</span>)</div><div class="line"></div><div class="line"><span class="comment"># x轴每个标签的具体位置，设置为每个柱的中央</span></div><div class="line">ax.set_xticks(xticks)</div><div class="line"></div><div class="line"><span class="comment"># 设置每个标签的名字</span></div><div class="line">ax.set_xticklabels(animals)</div><div class="line"></div><div class="line"><span class="comment"># 设置x轴的范围 ---轴不变, 在轴上显示多少, 直接决定柱子好不好看</span></div><div class="line">ax.set_xlim([bar_width/<span class="number">2</span><span class="number">-1</span>, <span class="number">3</span>-bar_width/<span class="number">2</span>])</div><div class="line"></div><div class="line"><span class="comment"># 设置y轴的范围</span></div><div class="line">ax.set_ylim([<span class="number">0</span>, <span class="number">125</span>])</div><div class="line"></div><div class="line"><span class="comment"># 给每个bar分配指定的颜色</span></div><div class="line"><span class="keyword">for</span> bar, color <span class="keyword">in</span> zip(bars, colors):</div><div class="line">    bar.set_color(color)</div><div class="line">    </div><div class="line"><span class="comment"># 在122位置加入新的图</span></div><div class="line">ax = fig.add_subplot(<span class="number">122</span>)</div><div class="line">ax.set_title(<span class="string">'Running speed - pie chart'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 生成同时包含名称和速度的标签</span></div><div class="line">labels = [<span class="string">'&#123;&#125;\n&#123;&#125; km/h'</span>.format(animal, speed) <span class="keyword">for</span> animal, speed <span class="keyword">in</span> zip(animals, speeds)]</div><div class="line"></div><div class="line"><span class="comment"># 画饼状图，并指定标签和对应颜色</span></div><div class="line">ax.pie(speeds, labels=labels, colors=colors)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/images/matplotlib使用/output_5_0.png" alt="output_5_0"></p>
<h2 id="3D-图表"><a href="#3D-图表" class="headerlink" title="3D 图表"></a>3D 图表</h2><p>Matplotlib中也能支持一些基础的3D图表，比如曲面图，散点图和柱状图。这些3D图表需要使用mpl_toolkits模块</p>
<blockquote>
<p>python2 python3 原来1/2（两个整数相除）结果是0，现在是0.5了<br>python 2.2+ 以上都可以使用 from <strong>future</strong> import division 实现改特性, 同时注意 // 取代了之前的 / 运算</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="comment"># 3D图标必须的模块，project='3d'的定义</span></div><div class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</div><div class="line"></div><div class="line">np.random.seed(<span class="number">42</span>)</div><div class="line">n_grids = <span class="number">51</span>        <span class="comment"># x-y平面的格点数 </span></div><div class="line">c = n_grids//<span class="number">2</span>    	<span class="comment"># 中心位置</span></div><div class="line">nf = <span class="number">2</span>             	<span class="comment"># 低频成分的个数</span></div><div class="line"></div><div class="line"><span class="comment"># 生成格点</span></div><div class="line">x = np.linspace(<span class="number">0</span>, <span class="number">1</span>, n_grids)</div><div class="line">y = np.linspace(<span class="number">0</span>, <span class="number">1</span>, n_grids)</div><div class="line"></div><div class="line"><span class="comment"># x和y是长度为n_grids的array</span></div><div class="line"><span class="comment"># meshgrid会把x和y组合成n_grids*n_grids的array，X和Y对应位置就是所有格点的坐标</span></div><div class="line">X, Y = np.meshgrid(x, y)</div><div class="line"></div><div class="line"><span class="comment"># 生成一个0值的傅里叶谱</span></div><div class="line">spectrum = np.zeros((n_grids, n_grids), dtype=np.complex)</div><div class="line"></div><div class="line"><span class="comment"># 生成一段噪音，长度是(2*nf+1)**2/2</span></div><div class="line"><span class="comment">#noise = [np.complex(x, y) for x, y in np.random.uniform(-1, 1, ((2*nf+1)**2/2, 2))]</span></div><div class="line">noise = [np.complex(x, y) <span class="keyword">for</span> x, y <span class="keyword">in</span> np.random.uniform(<span class="number">-1</span>,<span class="number">1</span>,((<span class="number">2</span>*nf+<span class="number">1</span>)**<span class="number">2</span>//<span class="number">2</span>, <span class="number">2</span>))]</div><div class="line"></div><div class="line"><span class="comment"># 傅里叶频谱的每一项和其共轭关于中心对称</span></div><div class="line">noise_block = np.concatenate((noise, [<span class="number">0j</span>], np.conjugate(noise[::<span class="number">-1</span>])))</div><div class="line"></div><div class="line"><span class="comment"># 将生成的频谱作为低频成分</span></div><div class="line">spectrum[c-nf:(c+nf+<span class="number">1</span>), c-nf:c+nf+<span class="number">1</span>] = noise_block.reshape((<span class="number">2</span>*nf+<span class="number">1</span>, <span class="number">2</span>*nf+<span class="number">1</span>))</div><div class="line"></div><div class="line"><span class="comment"># 进行反傅里叶变换</span></div><div class="line">Z = np.real(np.fft.ifft2(np.fft.ifftshift(spectrum)))</div><div class="line"></div><div class="line"><span class="comment"># 创建图表</span></div><div class="line">fig = plt.figure(<span class="string">'3D surface &amp; wire'</span>, figsize=(<span class="number">12</span>, <span class="number">6</span>))</div><div class="line"></div><div class="line"><span class="comment"># 第一个子图，surface图</span></div><div class="line">ax = fig.add_subplot(<span class="number">121</span>, projection=<span class="string">'3d'</span>)</div><div class="line"></div><div class="line"><span class="comment"># alpha定义透明度，cmap是color map</span></div><div class="line"><span class="comment"># rstride和cstride是两个方向上的采样，越小越精细，lw是线宽</span></div><div class="line">ax.plot_surface(X, Y, Z, alpha=<span class="number">0.7</span>, cmap=<span class="string">'jet'</span>, rstride=<span class="number">1</span>, cstride=<span class="number">1</span>, lw=<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="comment"># 第二个子图，网线图</span></div><div class="line">ax = fig.add_subplot(<span class="number">122</span>, projection=<span class="string">'3d'</span>)</div><div class="line">ax.plot_wireframe(X, Y, Z, rstride=<span class="number">3</span>, cstride=<span class="number">3</span>, lw=<span class="number">0.5</span>)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/images/matplotlib使用/output_7_0.png" alt="output_7_0"></p>
<p><strong>3D的散点图</strong></p>
<p>也是常常用来查看空间样本分布的一种手段，并且画起来比表面图和网线图更加简单</p>
<p>这个例子中，为了方便，直接先采样了一堆3维的正态分布样本，保证方向上的均匀性。然后归一化，让每个样本到原点的距离为1，相当于得到了一个均匀分布在球面上的样本。再接着把每个样本都乘上一个均匀分布随机数的开3次方，这样就得到了在球体内均匀分布的样本，最后根据判别平面3x+2y-z-1=0对平面两侧样本用不同的形状和颜色画出，图像如下：</p>
<blockquote>
<p>shape[0]  看行数, 即第一维数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</div><div class="line"></div><div class="line">np.random.seed(<span class="number">42</span>)</div><div class="line"></div><div class="line"><span class="comment"># 采样个数500</span></div><div class="line">n_samples = <span class="number">500</span></div><div class="line">dim = <span class="number">3</span></div><div class="line"></div><div class="line"><span class="comment"># 先生成一组3维正态分布数据，数据方向完全随机</span></div><div class="line">samples = np.random.multivariate_normal(</div><div class="line">    np.zeros(dim),</div><div class="line">    np.eye(dim),</div><div class="line">    n_samples</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment"># 通过把每个样本到原点距离和均匀分布吻合得到球体内均匀分布的样本</span></div><div class="line"><span class="comment"># samples[i] / np.linalg.norm(samples[i]) 归一化  (二范数是向量长度)</span></div><div class="line"><span class="comment"># r 一个均匀分布随机数的开3次方</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(samples.shape[<span class="number">0</span>]):</div><div class="line">    r = np.power(np.random.random(), <span class="number">1.0</span>/<span class="number">3.0</span>)</div><div class="line">    samples[i] *= r / np.linalg.norm(samples[i])</div><div class="line"></div><div class="line">upper_samples = []</div><div class="line">lower_samples = []</div><div class="line"></div><div class="line"><span class="keyword">for</span> x, y, z <span class="keyword">in</span> samples:</div><div class="line">     <span class="comment"># 3x+2y-z=1作为判别平面</span></div><div class="line">    <span class="keyword">if</span> z &gt; <span class="number">3</span>*x + <span class="number">2</span>*y - <span class="number">1</span>:</div><div class="line">        upper_samples.append((x, y, z))</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        lower_samples.append((x, y, z))</div><div class="line">        </div><div class="line">fig = plt.figure(<span class="string">'3D scatter plot'</span>)</div><div class="line">ax = fig.add_subplot(<span class="number">111</span>, projection=<span class="string">'3d'</span>)</div><div class="line">uppers = np.array(upper_samples)</div><div class="line">lowers = np.array(lower_samples)</div><div class="line"></div><div class="line"><span class="comment"># 用不同颜色不同形状的图标表示平面上下的样本</span></div><div class="line"><span class="comment"># 判别平面上半部分为红色圆点，下半部分为绿色三角</span></div><div class="line">ax.scatter(uppers[:, <span class="number">0</span>], uppers[:, <span class="number">1</span>], uppers[:, <span class="number">2</span>], c=<span class="string">'r'</span>, marker=<span class="string">'o'</span>)</div><div class="line">ax.scatter(lowers[:, <span class="number">0</span>], lowers[:, <span class="number">1</span>], lowers[:, <span class="number">2</span>], c=<span class="string">'g'</span>, marker=<span class="string">'^'</span>)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/images/matplotlib使用/output_9_0.png" alt="output_9_0"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>)</div><div class="line">y = np.linspace(<span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>)</div><div class="line">X, Y = np.meshgrid(x, y)</div><div class="line">X.shape[<span class="number">1</span>]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">10</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 展示画一个3d图</span></div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="comment"># 导入3D 包</span></div><div class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</div><div class="line"></div><div class="line"><span class="comment"># 将会话框进行对象化</span></div><div class="line">fig = plt.figure()</div><div class="line"><span class="comment"># 将对话框划分为一个子图, 并指定为3d图</span></div><div class="line">ax = fig.add_subplot(<span class="number">111</span>, projection=<span class="string">'3d'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 定义 x, y, z 三个坐标轴的数据集</span></div><div class="line">U = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]</div><div class="line">V = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>]</div><div class="line">W = [<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>]</div><div class="line"></div><div class="line"><span class="comment"># 用函数填满 4个点组成的三角形空间</span></div><div class="line">ax.plot_trisurf(U, V, W)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/images/matplotlib使用/output_11_0.png" alt="output_11_0"></p>
<h2 id="图像显示"><a href="#图像显示" class="headerlink" title="图像显示"></a>图像显示</h2><p>Matplotlib也支持图像的存取和显示，并且和OpenCV一类的接口比起来，对于一般的二维矩阵的可视化要方便很多：</p>
<p>这段代码中第一个例子是读取一个本地图片并显示，第二个例子中直接把上小节中反傅里叶变换生成的矩阵作为图像拿过来，原图和经过乘以3再加4变换的图直接绘制了两个形状一样，但是值的范围不一样的图案。显示的时候imshow会自动进行归一化，把最亮的值显示为纯白，最暗的值显示为纯黑。这是一种非常方便的设定，尤其是查看深度学习中某个卷积层的响应图时。得到图像如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="comment"># 读取一张手机的照片并显示</span></div><div class="line">plt.figure(<span class="string">'A little White iPhone'</span>)</div><div class="line">little_iPhone_img = plt.imread(<span class="string">'iPhone.png'</span>)</div><div class="line">plt.imshow(little_iPhone_img)</div><div class="line"></div><div class="line"><span class="comment"># Z是上小节生成的随机图案，img0就是Z，img1是Z做了个简单的变换</span></div><div class="line">img0 = Z</div><div class="line">img1 = <span class="number">3</span>*Z + <span class="number">4</span></div><div class="line"></div><div class="line"><span class="comment"># cmap指定为'gray'用来显示灰度图</span></div><div class="line">fig = plt.figure(<span class="string">'Auto Normalized Visualization'</span>)</div><div class="line">ax0 = fig.add_subplot(<span class="number">121</span>)</div><div class="line">ax0.imshow(img0, cmap=<span class="string">'gray'</span>)</div><div class="line"></div><div class="line">ax1 = fig.add_subplot(<span class="number">122</span>)</div><div class="line">ax1.imshow(img1, cmap=<span class="string">'gray'</span>)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/images/matplotlib使用/output_13_0.png" alt="output_13_0"></p>
<p><img src="/images/matplotlib使用/output_13_1.png" alt="output_13_1"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[numpy 使用]]></title>
      <url>http://yoursite.com/2017/12/22/numpy%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>python-numpy 基础</p>
<a id="more"></a>
<h1 id="入门-numpy-篇"><a href="#入门-numpy-篇" class="headerlink" title="入门 numpy 篇"></a>入门 numpy 篇</h1><h2 id="numpy-篇"><a href="#numpy-篇" class="headerlink" title="numpy 篇"></a>numpy 篇</h2><p>array，也就是数组，是numpy中最基础的数据结构, 最关键的属性是<strong>维度</strong>和<strong>元素类型</strong>, 在numpy中，可以非常方便地创建各种不同类型的多维数组，并且执行一些基本基本操作</p>
<blockquote>
<p>array 维度 元素类型</p>
</blockquote>
<h3 id="基本类型（array"><a href="#基本类型（array" class="headerlink" title="基本类型（array)"></a>基本类型（array)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%matplotlib inline</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#%load douban.py</span></div><div class="line"><span class="comment"># run douban.py</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!python --version</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Python 2.7.10</div></pre></td></tr></table></figure>
<h4 id="创建数组-获取数组的属性"><a href="#创建数组-获取数组的属性" class="headerlink" title="创建数组, 获取数组的属性"></a>创建数组, 获取数组的属性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">np.arange(<span class="number">15</span>).reshape(<span class="number">3</span>,<span class="number">5</span>)</div><div class="line"><span class="comment"># 在从1到3中产生9个数：(等差数列)</span></div><div class="line">np.linspace(<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>)</div><div class="line"></div><div class="line"><span class="comment"># 创建矩阵</span></div><div class="line">np.zeros((<span class="number">3</span>, <span class="number">4</span>))</div><div class="line"><span class="comment"># 2x2x3的无符号8位整型3维数组，并且初始化所有元素值为0</span></div><div class="line">g = np.zeros((<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>), dtype=np.uint8)</div><div class="line">print(g)</div><div class="line"> <span class="comment"># 用另一种类型表示</span></div><div class="line">g.astype(np.float)</div><div class="line"></div><div class="line">np.ones((<span class="number">3</span>, <span class="number">4</span>))</div><div class="line"></div><div class="line">np.eye(<span class="number">3</span>)</div><div class="line"></div><div class="line"><span class="comment"># 创建一个一维数组，元素值是把3重复4次，array([3, 3, 3, 3])</span></div><div class="line">np.repeat(<span class="number">3</span>, <span class="number">4</span>)</div><div class="line"></div><div class="line"><span class="comment"># 三维数组</span></div><div class="line">a = np.zeros((<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>))</div><div class="line"><span class="comment"># 数组的维数</span></div><div class="line">a.ndim</div><div class="line"><span class="comment"># 数组每一维的大小</span></div><div class="line">a.shape</div><div class="line"><span class="comment"># 数组的元素数</span></div><div class="line">a.size</div><div class="line"><span class="comment"># 元素类型  dtype('float64')</span></div><div class="line">a.dtype</div><div class="line"><span class="comment"># 每个元素所占的字节数 8</span></div><div class="line">a.itemsize</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[[0 0 0]</div><div class="line">  [0 0 0]]</div><div class="line"></div><div class="line"> [[0 0 0]</div><div class="line">  [0 0 0]]]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">8</div></pre></td></tr></table></figure>
<p>load()和save()用Numpy专用的二进制格式保存数据，它们会自动处理元素类型和形状等信息。savez()提供了将多个数组存储至一个文件的能力，调用load()方法返回的对象，可以使用数组名对各个数组进行读取。默认数组名arr_0,arr_1,arr_2……</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 关于文件</span></div><div class="line"><span class="comment"># 保存到文件</span></div><div class="line"><span class="comment"># 保存为二进制 第二个参数为要存的数组</span></div><div class="line">np.save(<span class="string">'p.npy'</span>, a)</div><div class="line"><span class="comment"># 保存为txt</span></div><div class="line">np.savetxt(<span class="string">'001'</span>, (<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>))</div><div class="line"></div><div class="line"><span class="comment"># 读取数据</span></div><div class="line">q = np.load(<span class="string">'p.npy'</span>)</div><div class="line">qq = np.loadtxt(<span class="string">'001'</span>)</div><div class="line">print(q)</div><div class="line">print(qq)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ 11.  12.  13.]</div></pre></td></tr></table></figure>
<h4 id="数组索引，切片，赋值"><a href="#数组索引，切片，赋值" class="headerlink" title="数组索引，切片，赋值"></a>数组索引，切片，赋值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 切片不能直接print</span></div><div class="line">a = np.array([[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]])</div><div class="line">print(a)</div><div class="line"><span class="comment"># 索引, 行列</span></div><div class="line">b = a[<span class="number">1</span>, <span class="number">2</span>]</div><div class="line">print(b)</div><div class="line"><span class="comment"># 切片, 得到数组</span></div><div class="line">b = a[<span class="number">1</span>,:]</div><div class="line">print(b)</div><div class="line"><span class="comment"># 切片, 得到数组</span></div><div class="line">b = a[<span class="number">1</span>, <span class="number">1</span>:<span class="number">2</span>]</div><div class="line">print(b)</div><div class="line">a[<span class="number">1</span>,:] = [<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</div><div class="line">print(a)</div><div class="line"></div><div class="line"><span class="comment"># 平均分成3份</span></div><div class="line">g = np.split(np.arange(<span class="number">9</span>), <span class="number">3</span>)</div><div class="line">print(g)</div><div class="line"></div><div class="line"><span class="comment"># 按照下标位置进行划分</span></div><div class="line">h = np.split(np.arange(<span class="number">9</span>), [<span class="number">2</span>, <span class="number">-3</span>])</div><div class="line"></div><div class="line"><span class="comment"># 使用 for 操作元素</span></div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.linspace(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>):</div><div class="line">    print(x)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[[2 3 4]</div><div class="line"> [5 6 7]]</div><div class="line">7</div><div class="line">[5 6 7]</div><div class="line">[6]</div><div class="line">[[ 2  3  4]</div><div class="line"> [ 8  9 10]]</div><div class="line">[array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8])]</div><div class="line">1.0</div><div class="line">2.0</div><div class="line">3.0</div></pre></td></tr></table></figure>
<h4 id="基本的数组运算"><a href="#基本的数组运算" class="headerlink" title="基本的数组运算"></a>基本的数组运算</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">a = np.ones((<span class="number">2</span>, <span class="number">2</span>))</div><div class="line">b = np.eye(<span class="number">2</span>)</div><div class="line">print(a&gt;<span class="number">2</span>)</div><div class="line">print(a+b)</div><div class="line">print(a-b)</div><div class="line">print(b*<span class="number">2</span>)</div><div class="line">print((a*<span class="number">2</span>)*(b*<span class="number">2</span>))</div><div class="line">print(b/(a*<span class="number">2</span>))</div><div class="line">print((a*<span class="number">2</span>)**<span class="number">4</span>)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[[False False]</div><div class="line"> [False False]]</div><div class="line">[[ 2.  1.]</div><div class="line"> [ 1.  2.]]</div><div class="line">[[ 0.  1.]</div><div class="line"> [ 1.  0.]]</div><div class="line">[[ 2.  0.]</div><div class="line"> [ 0.  2.]]</div><div class="line">[[ 4.  0.]</div><div class="line"> [ 0.  4.]]</div><div class="line">[[ 0.5  0. ]</div><div class="line"> [ 0.   0.5]]</div><div class="line">[[ 16.  16.]</div><div class="line"> [ 16.  16.]]</div></pre></td></tr></table></figure>
<p>numerical python，基础数学运算也是强大的: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">np.abs(<span class="number">-1</span>)   </div><div class="line">np.sin(np.pi/<span class="number">2</span>)  </div><div class="line">np.arctanh(<span class="number">0.462118</span>)</div><div class="line">d = np.exp(<span class="number">3</span>)</div><div class="line">f = np.power(<span class="number">2</span>, <span class="number">3</span>)</div><div class="line">g = np.dot([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>])</div><div class="line">h = np.sqrt(<span class="number">25</span>)</div><div class="line">l = np.sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</div><div class="line">m = np.mean([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</div><div class="line"><span class="comment"># 标准差</span></div><div class="line">p = np.std([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 使用数组对象自带的方法</span></div><div class="line">print(a.sum())</div><div class="line"><span class="comment"># 计算每一列的和（二维数组中类似于矩阵的列）的和</span></div><div class="line">print(a.sum(axis=<span class="number">0</span>))</div><div class="line"></div><div class="line">a.min()</div><div class="line">a.max()</div><div class="line">a.mean()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">3.0</div><div class="line">[ 2.  1.]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0.75</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 使用numpy下的方法：</span></div><div class="line">print(np.sin(a))</div><div class="line">print(np.max(a))</div><div class="line"><span class="comment"># 向下取整, 取不大于x的整数</span></div><div class="line">print(np.floor(a))</div><div class="line">print(np.exp(a))</div><div class="line"></div><div class="line"><span class="comment"># 矩阵乘法</span></div><div class="line">print(np.dot(a, a))</div><div class="line">print(<span class="string">'-----'</span>)</div><div class="line">print(a)</div><div class="line">print(b)</div><div class="line"><span class="comment"># 合并数组</span></div><div class="line"><span class="comment"># 使用numpy下的vstack和hstack函数：</span></div><div class="line"><span class="comment"># 只能同行同列</span></div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line">vstack是指沿着纵轴拼接两个array，vertical</div><div class="line">hstack是指沿着横轴拼接两个array，horizontal</div><div class="line">更广义的拼接用concatenate实现，horizontal后的两句依次等效于vstack和hstack</div><div class="line">stack不是拼接而是在输入array的基础上增加一个新的维度</div><div class="line">'''</div><div class="line">r = np.concatenate((a, b), axis=<span class="number">-1</span>)</div><div class="line"></div><div class="line">c = np.vstack((a, b))</div><div class="line">print(c)</div><div class="line">d = np.hstack((a, b))</div><div class="line">print(d)</div><div class="line"></div><div class="line"><span class="comment"># 深拷贝</span></div><div class="line"><span class="comment"># 即更改 a b 数, c不会发生改变</span></div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">[[ 0.84147098  0.84147098]</div><div class="line"> [ 0.84147098  0.        ]]</div><div class="line">1.0</div><div class="line">[[ 1.  1.]</div><div class="line"> [ 1.  0.]]</div><div class="line">[[ 2.71828183  2.71828183]</div><div class="line"> [ 2.71828183  1.        ]]</div><div class="line">[[ 2.  1.]</div><div class="line"> [ 1.  1.]]</div><div class="line">-----</div><div class="line">[[ 1.  1.]</div><div class="line"> [ 1.  0.]]</div><div class="line">[[ 1.  1.]</div><div class="line"> [ 1.  0.]]</div><div class="line">[[ 1.  1.]</div><div class="line"> [ 1.  0.]</div><div class="line"> [ 1.  1.]</div><div class="line"> [ 1.  0.]]</div><div class="line">[[ 1.  1.  1.  1.]</div><div class="line"> [ 1.  0.  1.  0.]]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 数组对象自带了浅拷贝和深拷贝的方法，但是一般用深拷贝多一些</span></div><div class="line"><span class="comment"># 浅拷贝</span></div><div class="line">a = np.ones((<span class="number">2</span>, <span class="number">2</span>))</div><div class="line">b = a</div><div class="line">a[<span class="number">1</span>,<span class="number">1</span>] = <span class="number">4</span></div><div class="line">print(b <span class="keyword">is</span> a)</div><div class="line">print(b)</div><div class="line"></div><div class="line"><span class="comment"># 深拷贝</span></div><div class="line">c = a.copy()</div><div class="line">a[<span class="number">1</span>, <span class="number">1</span>] = <span class="number">0</span></div><div class="line">print(c)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">True</div><div class="line">[[ 1.  1.]</div><div class="line"> [ 1.  4.]]</div><div class="line">[[ 1.  1.]</div><div class="line"> [ 1.  4.]]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 转置</span></div><div class="line">e = np.array([[<span class="number">2</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">6</span>]])</div><div class="line">print(e)</div><div class="line">print(e.transpose())</div><div class="line"><span class="comment"># 按指定轴进行转置</span></div><div class="line">t = e.transpose((<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>))</div><div class="line"><span class="comment"># 逆时针旋转90度，第二个参数是旋转次数</span></div><div class="line">v = np.rot90(e, <span class="number">3</span>)</div><div class="line"><span class="comment"># 沿纵轴左右翻转</span></div><div class="line">w = np.fliplr(e)</div><div class="line"><span class="comment"># 沿水平轴上下翻转</span></div><div class="line">x = np.flipud(e)</div><div class="line"><span class="comment"># 按照一维顺序滚动位移</span></div><div class="line">y = np.roll(e, <span class="number">1</span>)</div><div class="line"><span class="comment"># 按照指定轴滚动位移</span></div><div class="line">z = np.roll(e, <span class="number">1</span>, axis=<span class="number">1</span>)</div><div class="line"><span class="comment"># 迹</span></div><div class="line">np.trace(a)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[2 3]</div><div class="line"> [5 6]]</div><div class="line">[[2 5]</div><div class="line"> [3 6]]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1.0</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># numpy.linalg模块中有很多关于矩阵运算的方法：</span></div><div class="line"><span class="keyword">import</span> numpy.linalg <span class="keyword">as</span> nplg</div><div class="line"></div><div class="line"><span class="comment"># 特征值 特征向量</span></div><div class="line">nplg.eig(a)</div><div class="line"></div><div class="line">print(a)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[ 1.  1.]</div><div class="line"> [ 1.  0.]]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">c = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]])</div><div class="line"><span class="comment"># 每一列的最大值</span></div><div class="line">c.max(axis=<span class="number">1</span>)</div><div class="line"><span class="comment"># 每一行的均值</span></div><div class="line">c.mean(axis=<span class="number">0</span>) </div><div class="line"></div><div class="line"><span class="comment"># 展开一个numpy数组为1维数组，array([1, 2, 3, 4])</span></div><div class="line">c.flatten()</div><div class="line"><span class="comment"># 展开一个可以解析的结构为1维数组，array([1, 2, 3, 4]) </span></div><div class="line">np.ravel(c)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array([1, 2, 3, 4])</div></pre></td></tr></table></figure>
<h3 id="线性代数模块-linalg"><a href="#线性代数模块-linalg" class="headerlink" title="线性代数模块 (linalg)"></a>线性代数模块 (linalg)</h3><p>在深度学习相关的数据处理和运算中，线性代数模块（linalg）是最常用的之一. 结合numpy提供的基本函数，可以对向量，矩阵，或是说多维张量进行一些基本的运算. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">a = np.array([<span class="number">3</span>, <span class="number">4</span>])</div><div class="line"></div><div class="line"><span class="comment"># norm则表示范数，首先需要注意的是范数是对向量（或者矩阵）的度量，是一个标量（scalar）：</span></div><div class="line">np.linalg.norm(a)</div><div class="line"></div><div class="line">b = np.array([</div><div class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</div><div class="line">    [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</div><div class="line">    [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</div><div class="line">])</div><div class="line"></div><div class="line">c = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="comment"># 矩阵和向量之间的乘法  ???</span></div><div class="line">np.dot(b, c)</div><div class="line">np.dot(c, b.T)</div><div class="line"></div><div class="line"><span class="comment"># 求矩阵的迹，15(一个n×n矩阵A的主对角线（从左上方至右下方的对角线）</span></div><div class="line"><span class="comment"># 上各个元素的总和被称为矩阵A的迹)</span></div><div class="line">np.trace(b)</div><div class="line"><span class="comment"># 求矩阵的行列式值，0</span></div><div class="line">np.linalg.det(b)</div><div class="line"><span class="comment"># 求矩阵的秩，2，不满秩，因为行与行之间等差</span></div><div class="line">np.linalg.matrix_rank(b)</div><div class="line"></div><div class="line">d = np.array([</div><div class="line">    [<span class="number">2</span>, <span class="number">1</span>],</div><div class="line">    [<span class="number">1</span>, <span class="number">2</span>]</div><div class="line">])</div><div class="line"><span class="string">'''</span></div><div class="line">对正定矩阵求本征值和本征向量</div><div class="line">本征值为u，array([ 3.,  1.])</div><div class="line">本征向量构成的二维array为v，</div><div class="line">array([[ 0.70710678, -0.70710678],</div><div class="line">       [ 0.70710678,  0.70710678]])</div><div class="line">是沿着45°方向</div><div class="line">eig()是一般情况的本征值分解，对于更常见的对称实数矩阵，</div><div class="line">eigh()更快且更稳定，不过输出的值的顺序和eig()是相反的</div><div class="line">'''</div><div class="line"></div><div class="line">u, v = np.linalg.eig(d)</div><div class="line">print(u, v)</div><div class="line"></div><div class="line"><span class="comment"># Cholesky分解并重建</span></div><div class="line"><span class="comment"># 把一个对称正定的矩阵表示成一个下三角矩阵L和其转置的乘积的分解</span></div><div class="line">l = np.linalg.cholesky(d)</div><div class="line">np.dot(l, l.T)</div><div class="line"></div><div class="line">e = np.array([</div><div class="line">    [<span class="number">1</span>, <span class="number">2</span>],</div><div class="line">    [<span class="number">3</span>, <span class="number">4</span>]</div><div class="line">])</div><div class="line"></div><div class="line"><span class="comment"># 对不镇定矩阵，进行SVD分解(奇异值分解)并重建</span></div><div class="line">U, s, V = np.linalg.svd(e)</div><div class="line"></div><div class="line">S = np.array([</div><div class="line">   [s[<span class="number">0</span>], <span class="number">0</span>],</div><div class="line">    [<span class="number">0</span>, s[<span class="number">1</span>]]</div><div class="line">])</div><div class="line">np.dot(U, np.dot(S, V))</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[ 3.  1.] [[ 0.70710678 -0.70710678]</div><div class="line"> [ 0.70710678  0.70710678]]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">array([[ 1.,  2.],</div><div class="line">       [ 3.,  4.]])</div></pre></td></tr></table></figure>
<h3 id="随机模块（random）"><a href="#随机模块（random）" class="headerlink" title="随机模块（random）"></a>随机模块（random）</h3><p>包含了随机数产生和统计分布相关的基本函数, Python本身也有随机模块random，不过功能更丰富</p>
<p><strong>注意: 方法参数中都是规定产生随机数的数量(一维, 二维a*b)</strong>, 并非是产生的大小</p>
<h4 id="随机数产生"><a href="#随机数产生" class="headerlink" title="随机数产生"></a>随机数产生</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> numpy.random <span class="keyword">as</span> random</div><div class="line"></div><div class="line"><span class="comment"># 设置随机数种子</span></div><div class="line">random.seed(<span class="number">42</span>)</div><div class="line"><span class="comment"># 产生一个1x3 数组，[0,1)之间的浮点型随机数</span></div><div class="line">random.rand(<span class="number">1</span>, <span class="number">3</span>)</div><div class="line"><span class="comment"># 产生一个[0,1)之间的浮点型随机数</span></div><div class="line">random.random()</div><div class="line"></div><div class="line"><span class="comment"># 下边4个没有区别，都是按照指定大小产生[0,1)之间的浮点型随机数array，不Pythonic…</span></div><div class="line">random.random((<span class="number">3</span>, <span class="number">3</span>))</div><div class="line">random.sample((<span class="number">3</span>, <span class="number">3</span>))</div><div class="line">random.random_sample((<span class="number">3</span>, <span class="number">3</span>))</div><div class="line">random.ranf((<span class="number">3</span>, <span class="number">3</span>))</div><div class="line"></div><div class="line"><span class="comment"># 产生10个[1,6)之间的浮点型随机数</span></div><div class="line"><span class="number">5</span>*random.random(<span class="number">10</span>) + <span class="number">1</span></div><div class="line"><span class="comment"># (3, 3)生成二维</span></div><div class="line">random.uniform(<span class="number">1</span>, <span class="number">6</span>, <span class="number">10</span>) </div><div class="line"></div><div class="line"><span class="comment"># 产生10个[1,6)之间的整型随机数</span></div><div class="line">random.randint(<span class="number">1</span>, <span class="number">6</span>, <span class="number">10</span>)</div><div class="line"></div><div class="line"><span class="comment"># 产生2x5的标准正态分布样本</span></div><div class="line">random.normal(size=(<span class="number">5</span>, <span class="number">2</span>))</div><div class="line"></div><div class="line"><span class="comment"># 产生5个，n=5，p=0.5的二项分布样本</span></div><div class="line"></div><div class="line">random.binomial(n=<span class="number">5</span>, p=<span class="number">0.5</span>, size=<span class="number">5</span>)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array([3, 4, 4, 2, 1])</div></pre></td></tr></table></figure>
<h4 id="统计分布"><a href="#统计分布" class="headerlink" title="统计分布"></a>统计分布</h4><p>对具体的样本数据进行与统计分布相关操作</p>
<blockquote>
<p>in-place操作，意思是所有的操作都是”就地“操作，不允许进行移动，或者称作 <strong>原位操作</strong>，即不允许使用临时变量。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">10</span>)</div><div class="line"></div><div class="line"><span class="comment"># 从a中有回放的随机采样7个</span></div><div class="line">random.choice(a, <span class="number">7</span>)</div><div class="line"></div><div class="line"><span class="comment"># 从a中无回放的随机采样7个</span></div><div class="line">random.choice(a, <span class="number">7</span>, replace=<span class="keyword">False</span>)</div><div class="line"></div><div class="line"><span class="comment"># 对a进行乱序并返回一个新的array</span></div><div class="line">random.permutation(a)</div><div class="line"></div><div class="line"><span class="comment"># 对a进行in-place乱序</span></div><div class="line">random.shuffle(a)</div><div class="line">print(a)</div><div class="line"></div><div class="line"><span class="comment"># 生成一个长度为9的随机bytes序列并作为str返回</span></div><div class="line">random.bytes(<span class="number">9</span>)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[1 8 4 2 9 6 5 7 0 3]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b&apos;[4&amp;`a&#125;0\x94A&apos;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode1541]]></title>
      <url>http://yoursite.com/2017/03/15/LeetCode%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<h1 id="LeetCode-一"><a href="#LeetCode-一" class="headerlink" title="LeetCode(一)"></a><strong>LeetCode(一)</strong></h1><h3 id="Tag-Arrays-和Hash-1-15"><a href="#Tag-Arrays-和Hash-1-15" class="headerlink" title="Tag: Arrays 和Hash (1,15)"></a><strong>Tag: <code>Arrays</code> 和<code>Hash</code> (1,15)</strong></h3><h4 id="1-twoSum-返回目标值索引"><a href="#1-twoSum-返回目标值索引" class="headerlink" title="1. twoSum 返回目标值索引"></a><strong>1. twoSum 返回目标值索引</strong></h4><blockquote>
<p>本题学习过程帮助我了解vector, unordered_map和map</p>
</blockquote>
<p>我的思路: 先对vector<int>num进行sort排序, 进而头尾相加, 小于target则头指针加一; 大于则只尾指针减一; 等于跳出循环</int></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec(nums);</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result ;</div><div class="line">    sort(nums.begin(), nums.end());</div><div class="line">    <span class="keyword">int</span> a,b,c=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=nums.size()<span class="number">-1</span>; i&lt;=j; i++,j--)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> temp = nums.at(i) + nums.at(j);</div><div class="line">        <span class="keyword">if</span>(temp &lt; target) &#123;j++;&#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(temp &gt; target)&#123;i--;&#125;</div><div class="line">        <span class="keyword">else</span> &#123;a=nums.at(i); b=nums.at(j);<span class="keyword">break</span>;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;vec.size();k++)&#123;</div><div class="line">        <span class="keyword">if</span>(c==<span class="number">2</span>) <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">if</span>(vec.at(k) == a) &#123;result.push_back(k);c++;</div><div class="line">            <span class="keyword">continue</span>;&#125;</div><div class="line">        <span class="keyword">if</span>(vec.at(k) == b) &#123;result.push_back(k);c++;</div><div class="line">            <span class="keyword">continue</span>;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>网上解答</em></p>
<p>Solution/*将n方复杂度的转换为linear, 主要是使用map追踪正确需要的数, 把需要的值存进map</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)&#123;</div><div class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</div><div class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</div><div class="line">    <span class="keyword">int</span> numToFind = target - nums[i];</div><div class="line">    <span class="keyword">if</span>(hash.find(numsToFind) != hash.end())&#123;</div><div class="line">      result.push_back(hash[numsToFind]);</div><div class="line">      result.push_back(i);</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    hash[nums[i]] = i;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####<strong>3.  15. 3Sum</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">报错</div><div class="line">Runtime Error Message: reference binding to null pointer of type &apos;struct value_type&apos;</div><div class="line">原因: 没有验证输入是否为空数组(向量)</div><div class="line">解决:方法里加入if判断</div></pre></td></tr></table></figure>
<p>我的思路:  参照第一题, 先外层遍历i, target=0-nums[i], 在按照第一题的方法去做</p>
<p><strong>问题</strong>: 内层时需要考虑不中间返回, 以及去重问题, 耽误了我的时间复杂度, 😭😭😭</p>
<p>开始      <strong>但是,超时了</strong>妈个叽</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; hash; <span class="comment">//便于追踪正确值, 两个的情况</span></div><div class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; skip; <span class="comment">//存放已测试的num[i],用于跳过</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</div><div class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; repeat;</div><div class="line">        <span class="keyword">if</span> (nums.size() &lt; <span class="number">3</span>)&#123;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size()<span class="number">-2</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (skip.find(nums[i]) != skip.end()) <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">int</span> target = <span class="number">0</span> - nums[i];</div><div class="line">            hash.clear();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++) &#123;</div><div class="line">                <span class="keyword">int</span> numToFind = target - nums[j];</div><div class="line">                <span class="keyword">if</span> (skip.find(nums[j]) != skip.end() || skip.find(numToFind) != skip.end()) <span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">if</span>(hash.find(nums[j]) != hash.end())&#123;</div><div class="line">                    <span class="keyword">if</span>(numToFind != nums[j]) <span class="keyword">continue</span>;</div><div class="line">                    <span class="keyword">if</span>(repeat.find(numToFind) != repeat.end()) <span class="keyword">continue</span>;</div><div class="line">                    repeat.insert(numToFind);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (hash.find(numToFind) != hash.end()) &#123;</div><div class="line">                        tmp.push_back(numToFind);</div><div class="line">                        tmp.push_back(nums[j]);</div><div class="line">                        tmp.push_back(nums[i]);</div><div class="line">                        result.push_back(tmp);</div><div class="line">                        tmp.clear();</div><div class="line">                    &#125;</div><div class="line">                    hash.insert(nums[j]);</div><div class="line">            &#125;</div><div class="line">            skip.insert(nums[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//改成能accepted, 然而复杂度不忍直视😂</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; hash; <span class="comment">//便于追踪正确值, 两个的情况</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp; </div><div class="line">        <span class="keyword">if</span> (nums.size() &lt; <span class="number">3</span>) &#123;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        sort(nums.begin(), nums.end());</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">2</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> ((i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i - <span class="number">1</span>]) || i == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">int</span> target = <span class="number">0</span> - nums[i];</div><div class="line">                hash.clear();</div><div class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</div><div class="line">                <span class="keyword">while</span>(j &lt; nums.size()) &#123;</div><div class="line">                   <span class="keyword">int</span> numToFind = target - nums[j];</div><div class="line">                    <span class="keyword">if</span>(hash.find(numToFind) != hash.end())&#123;</div><div class="line">                        tmp.push_back(numToFind);</div><div class="line">                        tmp.push_back(nums[j]);</div><div class="line">                        tmp.push_back(nums[i]);</div><div class="line">                        result.push_back(tmp);</div><div class="line">                        tmp.clear();</div><div class="line">                        <span class="keyword">while</span>(j &lt; nums.size()<span class="number">-1</span> &amp;&amp; nums[j] == nums[j+<span class="number">1</span>]) j++;</div><div class="line">                        j++;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> hash.insert(nums[j++]);</div><div class="line">               &#125;</div><div class="line">    <span class="comment">//            for(it = hash.begin(); it!=hash.end(); it++)&#123;cout&lt;&lt;*it&lt;&lt;"  ";&#125;</span></div><div class="line">            &#125;</div><div class="line">    <span class="comment">//        cout&lt;&lt;endl;</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>参照网上的答案更改过后:</p>
<p><strong>问题明白两点</strong>    </p>
<ul>
<li>排序,先对给定数组进行排序 </li>
<li>有时, while循环比for循环更好用  优势在于更好的控制每一次 i+1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</div><div class="line">    sort(nums.begin(), nums.end());</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</div><div class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i<span class="number">-1</span>]))&#123;</div><div class="line">            <span class="keyword">int</span> lo = i + <span class="number">1</span>, hi= nums.size() - <span class="number">1</span>, sum = <span class="number">0</span> - nums[i];</div><div class="line">            <span class="keyword">while</span> (lo &lt; hi)&#123;</div><div class="line">              <span class="comment">//第一次允许, 以后通过排序直接跳过可能的重复</span></div><div class="line">                <span class="keyword">if</span> (nums[lo] + nums[hi] ==  sum)&#123;</div><div class="line">                    tmp.push_back(nums[i]);</div><div class="line">                    tmp.push_back(nums[lo]);</div><div class="line">                    tmp.push_back(nums[hi]);</div><div class="line">                    res.push_back(tmp);</div><div class="line">                    tmp.clear();</div><div class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == nums[lo + <span class="number">1</span>]) 					lo++;</div><div class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == nums[hi - <span class="number">1</span>]) 					hi--;</div><div class="line">                    lo++; hi--;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[lo] + nums[hi] &lt; sum) lo++;</div><div class="line">                <span class="keyword">else</span> hi--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>char<em> p = “test”; 这个声明，声明了一个指针，而这个指针指向的是<em>*全局的const内存区</em></em>，const内存区当然不会让你想改就改的。</p>
<h4 id="541-Reverse-String-II"><a href="#541-Reverse-String-II" class="headerlink" title="541.Reverse String II"></a><strong>541.Reverse String II</strong></h4><p>问题描述：一串小写字符，分<k, k<s<2k,="" s="">2k几种情况，每2k个字符第k个逆转到开头,k范围[1, 10000]</k,></p>
<p><strong>小问题</strong>(是我理解的问题还是)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="built_in">string</span> <span class="title">reverseStr</span><span class="params">(String str, <span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>; left&lt;str.size; left+= <span class="number">2</span>*k)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=left,j=min(left+k<span class="number">-1</span>, <span class="keyword">int</span>(s.size()<span class="number">-1</span>)); i&lt;j; i++,j--)</div><div class="line">        &#123;</div><div class="line">          swap(s[i], s[j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CG]]></title>
      <url>http://yoursite.com/2017/03/05/CG%E7%9F%A5%E8%AF%86%E7%82%B9%E9%A2%84%E4%BC%B0%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<h3 id="c11-shading"><a href="#c11-shading" class="headerlink" title="c11 shading"></a><strong>c11 shading</strong></h3><h4 id="phong模型包含-内容"><a href="#phong模型包含-内容" class="headerlink" title="phong模型包含(内容)"></a><strong>phong模型包含(内容)</strong></h4><ul>
<li>环境光, 漫反射, 镜面反射  </li>
<li>公式 四个向量</li>
<li>小细节   <strong>单独求r(反射向量)</strong>  以及  算法改进  <strong>引入H向量</strong> 向量之间计算</li>
<li>增加<strong>衰减因子</strong>(常数项和一次项作用—-当距离变远时, 减缓衰减速度)</li>
</ul>
<h4 id="使用多边形-mash-表示原因"><a href="#使用多边形-mash-表示原因" class="headerlink" title="使用多边形 mash 表示原因"></a><strong>使用多边形 mash 表示原因</strong></h4><ul>
<li>最主要: 可定向求法向, 用于光亮度计算; </li>
<li>可得到边的准确位置, 用于做扫描转换填充</li>
</ul>
<h4 id="phong及Gouraud特点及为什么"><a href="#phong及Gouraud特点及为什么" class="headerlink" title="phong及Gouraud特点及为什么"></a><strong>phong及Gouraud特点及为什么</strong></h4><ul>
<li>两个都是插值着色, G是双插颜色 P是双插法向 (一条边上插值点的法向; 多边形图元之间插边的法向 分离了每一个四角形,中间点可能会出现非垂直的法向)</li>
<li>gouraund 易实现,但未给高亮  (原因 多边形中间很可能存在高光区域, 但是边缘未出现高光)</li>
<li>phong 实现代价比较高, 但有比较好的高亮</li>
<li>使用: 如果表面曲率比较高, phong处理更光滑,但是代价比较高; 均需要数据结构来存储面片, 可以获得点的法向量</li>
</ul>
<h3 id="c12-vertices-to-Fragment-一"><a href="#c12-vertices-to-Fragment-一" class="headerlink" title="c12  vertices to Fragment 一"></a><strong>c12  vertices to Fragment 一</strong></h3><h4 id="关于-pipeline-的过程的具体实施"><a href="#关于-pipeline-的过程的具体实施" class="headerlink" title="关于 pipeline 的过程的具体实施"></a><strong>关于 pipeline 的过程的具体实施</strong></h4><ul>
<li>model —&gt;  Geometric processing (<strong>投影, 图元装配, 剪裁, 着色</strong>) —&gt; Rasterization  —&gt; Fragment processing (<strong>隐藏面消除, 纹理映射, 透明度</strong>)  —&gt; Frame buffer</li>
</ul>
<h4 id="Clipping-算法-内容简述"><a href="#Clipping-算法-内容简述" class="headerlink" title="Clipping 算法 (内容简述)"></a><strong>Clipping 算法 (内容简述)</strong></h4><h5 id="Cohen-Sutherland"><a href="#Cohen-Sutherland" class="headerlink" title="Cohen-Sutherland"></a><strong>Cohen-Sutherland</strong></h5><ul>
<li><p>4种case  重在排除两种 0 内 1 外  y 左 x 右 </p>
</li>
<li><p>理解 </p>
<blockquote>
<p>通过一个矩形的裁剪区域将整个屏幕分成9个部分，并为每一个部分赋予相应的区域码，然后根据端点的位置确定这个端点的区域码。</p>
<p>先判断能否完全接受或者完全排除一条线段，若以上2个判断无法直接得出，则逐步裁剪，选取一个位于裁剪区外的端点，把端点的区域码和裁剪边界的区域码进行逻辑与运算，若结果为真，则端点在该裁剪边界外部，这时将端点移向线段和该边界的交点处，如此循环，直到裁剪结束.</p>
</blockquote>
</li>
<li><p>优 (可排除多数情况; 易扩展至3d 3*9 6bit) 缺 (对于在多个步骤中要裁剪的线段需要多次重复编码,降低效率) 点</p>
</li>
<li><p>normalized form 归一化形式</p>
<ul>
<li>归一化, 中心在原点处,边长为2, 无论定义什么视界体, 对我们来说都是标准化的视界体, 从而不会影响结果.</li>
</ul>
</li>
</ul>
<h5 id="Cyrus-Beck-认为很重要-需要画图考"><a href="#Cyrus-Beck-认为很重要-需要画图考" class="headerlink" title="Cyrus-Beck (认为很重要, 需要画图考)"></a><strong>Cyrus-Beck (</strong>认为很重要, 需要画图考<strong>)</strong></h5><ul>
<li><p>算法简述 参数直线方程 求t= NL(P0-A)/-NL(P1-P0)    <strong>NL(P1-P0)</strong> 作为判断依据  &gt;0 进入点Pe &lt;0 出去点 PL  =0 判断 <strong>NL(P0-A)</strong>正负 (特殊情况)</p>
</li>
<li><p>伪码 了解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>（k edges of clipping polygon）</div><div class="line">&#123;</div><div class="line">    solve Ni·(p1-p0);</div><div class="line">    solve Ni·(p0-Ai);</div><div class="line">    <span class="keyword">if</span> ( Ni·(p1-p0) = = <span class="number">0</span> ) <span class="comment">//parallel with the edge</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> ( Ni·(p0-Ai) &lt; <span class="number">0</span> )</div><div class="line">             <span class="keyword">break</span>; <span class="comment">//invisible</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">             go to next edge;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>  <span class="comment">// Ni·(p1-p0) != 0</span></div><div class="line">    &#123;</div><div class="line">        solve ti;</div><div class="line">        <span class="keyword">if</span> ( Ni·(p1-p0) &lt; <span class="number">0</span> )</div><div class="line">          te = min&#123;<span class="number">1</span>, min&#123;ti| Ni*(P1-P0)&lt;<span class="number">0</span>&#125;&#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">		  tl = max&#123;<span class="number">0</span>, max&#123;ti| Ni*(P1-P0)&gt;<span class="number">0</span>&#125;&#125;</div><div class="line">     &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="Liang-Barsky-梁友栋"><a href="#Liang-Barsky-梁友栋" class="headerlink" title="Liang-Barsky (梁友栋)"></a><strong>Liang-Barsky (梁友栋)</strong></h5><ul>
<li>tL tR tB tT 求解(四个交点) 规律都有一个负号,其余样子一样</li>
<li>画图 裁剪窗口为规则矩形  Rk 和 Sk 的判断</li>
</ul>
<h5 id="三者比较"><a href="#三者比较" class="headerlink" title="三者比较"></a><strong>三者比较</strong></h5><ul>
<li>Cohen-Sutherland: 反复需要裁剪时代价比较高(每次均判断是否需裁); 当大多数线可排除, 只接受一小部分线时最适用</li>
<li>Cyrus-Beck: 计算 t 交点时代价比较低, (x, y) 裁剪点只计算一次; 但是算法不会考虑大部分都不显示的情况,最好是多条线段均需剪裁</li>
<li>Liang-Barsky: Cyrus­Beck的优化版</li>
</ul>
<h5 id="Sutherland-Hodgman-裁剪多边形"><a href="#Sutherland-Hodgman-裁剪多边形" class="headerlink" title="Sutherland-Hodgman (裁剪多边形)"></a><strong>Sutherland-Hodgman (裁剪多边形)</strong></h5><ul>
<li>独立考虑视口的每一条边; 使用边裁剪多边形; 做完所有平面多边形裁剪好   路线: 一次围绕polygon 一个顶点, 以前的s,现在的p 4种case <strong>画图</strong></li>
<li><strong>注意: 凸边形可以但凹变形不可, 可以扩展至3D</strong> </li>
</ul>
<h4 id="Rasterization-—-光栅化-扫描转换"><a href="#Rasterization-—-光栅化-扫描转换" class="headerlink" title="Rasterization — 光栅化, 扫描转换"></a><strong>Rasterization — 光栅化, 扫描转换</strong></h4><p>决定由顶点形成的基本图元包含的pixel; 片元是潜在的像素, 属性包括—位置信息, 颜色, 深度, 纹理坐标等; 片元的位置属性对应于颜色缓存中某个像素的位置。</p>
<h5 id="DDA-线段扫描转换算法"><a href="#DDA-线段扫描转换算法" class="headerlink" title="DDA (线段扫描转换算法)"></a><strong>DDA (线段扫描转换算法)</strong></h5><ul>
<li><p>根据直线斜率确定下一个 pixel 位置, m=△y, 假定0&lt;m&lt;1,  m大于1时,交换x, y</p>
</li>
<li><p>优 (实现容易) 缺 (每一步均涉及浮点运算和四舍五入, 代价比较高)</p>
</li>
<li><p>伪码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=x1; x&lt;=x2; x++)&#123;</div><div class="line">  y+=m; <span class="comment">//m是浮点数</span></div><div class="line">  write_pixel(x, round(y), line_color); <span class="comment">//round()四舍五入</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="Bresenham’s-很重要-画图考"><a href="#Bresenham’s-很重要-画图考" class="headerlink" title="Bresenham’s (很重要, 画图考)"></a><strong>Bresenham’s (</strong>很重要, 画图考<strong>)</strong></h5><ul>
<li><p>基本思想: 假定线段的起点(x1,y1)和终点(x2，y2)的坐标值都是整数, 假定通过计算已经得到了一个位于(i+1/2,j+1/2)位置的像素，该线段所在直线的方程为<br>y=mx+h, 下一个点的候选像素是 (Xi+1, Yi,r +1) 和 (Xi+1 , Yi,r) 引入判定变量 变为一种增量算法  d=△x(a-b), 直接判断B-A就行  Yi+1-Yi,r-0.5<img src="/images/CG/Bresenham.png" alt="Bresenham"></p>
</li>
<li><p><strong>改进(很重要😂, 会画图)</strong></p>
<ul>
<li><p><code>0&lt;m&gt;1</code> 时, 分两种情况: 第二次在第一次的右边;  此时Anew = Alast - m; Bnew =  Blast + m</p>
<p>第二次在第一次右上 Anew = Alast - (m-1);  Bnew =  Blast + (m-1)</p>
</li>
<li><p>伪码, 老师上课要做(重要😁)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bresenham</span><span class="params">(x0, y0, x1, y1)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> dx,dy,x,y,d;</div><div class="line">  dx = x1-x0;</div><div class="line">  dy = y1-y0;</div><div class="line">  d = dx<span class="number">-2</span>*(dy);<span class="comment">//d = △x(a-b)</span></div><div class="line">  x=x0; y=y0;</div><div class="line">  drawpixel(x, y, color);</div><div class="line">  <span class="keyword">while</span>(x&lt;=x1)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">if</span>(d&gt;<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">      x = x + <span class="number">1</span>;</div><div class="line">      y = y;</div><div class="line">      d = d - <span class="number">2</span>*(dy);<span class="comment">//增量  △x(2*m)= 2*△y</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      x = x + <span class="number">1</span>;</div><div class="line">      y = y + <span class="number">1</span>;</div><div class="line">      d = d - <span class="number">2</span>*(dy - dx);<span class="comment">//增量  △x(2*(m-1)= 2*(△y - △x)</span></div><div class="line">    &#125; </div><div class="line">    drawpixel(x, y, color);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="polygon-扫描转换-填充-Fill-奇异点问题注意"><a href="#polygon-扫描转换-填充-Fill-奇异点问题注意" class="headerlink" title="polygon 扫描转换(填充 Fill  奇异点问题注意)"></a><strong>polygon 扫描转换(填充 Fill  </strong>奇异点问题注意<strong>)</strong></h5><p>凸边形 检测点是否在多边形内—奇偶性检测 (奇内偶外), 非凸可能会用winding number (顺时针 交点-1 逆时针 交点+1 不为0 ,则在内)</p>
<ul>
<li>Flood Fill 泛洪单个pixel <ul>
<li>前提: 知道其中的一个种子点, 可以进行递归填充 4/8方向</li>
</ul>
</li>
<li>Flood Fill with scan line 一行<ul>
<li>最主要的 — 找准边界pixel, 可以通过上下行入栈但比较麻烦, 可以通过维护多边形与扫描线的所有交点的数据结构来填充12, 34, 56, 78, 910…</li>
<li><strong>奇异点排除问题</strong>  比较重要 多边形顶点恰在扫描线上.. 解决方式可以是将其中一种裁开,使得交点数量降低; (了解即好—openGL使用了两倍于帧缓存的虚拟缓存,像素中心在整数半值处, 不可能出现奇异点情况)</li>
</ul>
</li>
<li>coherence of scanline   一致性 改进算法, 增量计算<ul>
<li>之前步骤: 找到扫描线和每一条边的交点; 交点排序; 交点之间填充pixel; 缺点: 计算交点很慢</li>
<li>步骤: 利用奇偶性填充, 之前的奇异点必须处理好, 顶点计算两遍的排除.      <strong>难点</strong>: 在于如何快速找到第二条线, 两行扫描线的交点在polygon的同一条边上, 利用扫描线的连续性, <code>Xer = Xdr + 1/mr</code>   <code>△x= 1/m</code>  Xs+1 =  Xs + 1/m</li>
</ul>
</li>
</ul>
<h3 id="c13-Hidden-surface-removal"><a href="#c13-Hidden-surface-removal" class="headerlink" title="c13  Hidden surface removal"></a><strong>c13  Hidden surface removal</strong></h3><p>vertices to Fragment 二</p>
<h4 id="Object-Space方法"><a href="#Object-Space方法" class="headerlink" title="Object Space方法"></a><strong>Object Space方法</strong></h4><p>在polygon对象空间范围使用成对测试, n个多边形最差复杂度O(n^2)</p>
<h5 id="painter’s-算法-Depth-Sort"><a href="#painter’s-算法-Depth-Sort" class="headerlink" title="painter’s 算法 (Depth Sort)"></a><strong>painter’s 算法 (Depth Sort)</strong></h5><ul>
<li>基于对象空间, 先画后面的, 再画前面的 </li>
<li>深度排序 O(nlogn) 如果某个多边形的最小深度值z值大于它后面某个多边形的最大深度值, 先画; 当z值重叠时, 检测x或y的取值范围, 若x, y 不重叠, 则互不遮挡;如果均有重叠, 困难的情况: <ul>
<li>一个polygon的所有顶点均在另一个polygon所在平面的同一侧</li>
<li>3个或更多的polygon循环重叠  <strong>解决办法: 裁开 至少把其中一个多边形分割成两个多边形从而得到一个新多边形集</strong></li>
<li>polygon相互穿透</li>
</ul>
</li>
</ul>
<h4 id="Image-Space方法"><a href="#Image-Space方法" class="headerlink" title="Image Space方法"></a><strong>Image Space方法</strong></h4><p>n*m frame buffer 寻找最近的k个polygons  复杂度O(nmk)</p>
<h5 id="Back-Face-Removal-背向面剔除"><a href="#Back-Face-Removal-背向面剔除" class="headerlink" title="Back-Face Removal 背向面剔除"></a><strong>Back-Face Removal 背向面剔除</strong></h5><ul>
<li>减轻隐藏面清除的计算量, 前向角画背向角不画, 只适用凸边形 glCullFace()</li>
<li>v · n &gt;= 0   [-90, 90]</li>
<li>进一步简化, 归一化之后, 所有的投影为正交投影, v=(0, 0, 1) 平面方程 ax+by+cz+d=0 法向量(a, b, c) 只需考虑c即可</li>
</ul>
<h5 id="Z-Buffer-or-depth-Buffer-算法-增量计算-比较重要"><a href="#Z-Buffer-or-depth-Buffer-算法-增量计算-比较重要" class="headerlink" title="Z-Buffer  or  depth-Buffer 算法   增量计算 比较重要"></a><strong>Z-Buffer  or  depth-Buffer 算法   增量计算 比较重要</strong></h5><p>在图像空间, 初始化全部为∞, 先对多个polygon<strong>光栅化处理</strong>, 对于某个polygon上的每个片元, 它对应于通过某个pixel位置的射线与改多边形的交点, 计算片元到投影中心的距离(即<strong>片元的深度值</strong>), 将片元的深度值同z-buffer相应位置的深度值作比较.</p>
<p>  若前者大, 之前处理的片元离视点更近, 则不可见; 前者小, 则找到离视点更近的一个片元, 使用片元上的深度值更新z-buffer的值, 并把颜色缓存中的相应位置的颜色更新为该片元的颜色.</p>
<ul>
<li><p>注: 从透视投影的角度, 所求得深度值是经过了<strong>归一化变换后的距离</strong>. (虽然是非线性变换, 但相对距离不变)   视界体归一化, 透视投影变成正交投影, 可以利用z值进行深度计算</p>
</li>
<li><p>伪码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//initScreen 初始化</span></div><div class="line"><span class="keyword">for</span> i=<span class="number">0</span> to N <span class="keyword">do</span></div><div class="line">  <span class="keyword">for</span> j=<span class="number">0</span> to N <span class="keyword">do</span></div><div class="line">    screen[i][j] = BackGROUND_COLOR; zbuffer[i][j] = ∞</div><div class="line"><span class="comment">//DrawZpixel(x,y,z,color) 里的xyz经过正交投影归一化</span></div><div class="line"><span class="keyword">if</span>(z &lt; zbuffer[x][y]) then</div><div class="line">  screen[x][y] = color; zbuffer[x][y] = z;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>增量计算</strong> </p>
</li>
</ul>
<p>平面ax+by+cz+d=0 使用扫描线转化光栅化, 深度改变满足 a△x + b△y + c△z = 0 (窗口坐标系) 沿着扫描线 △y=0 △z = -a/c *△x  (△x = 1)  只需计算一次</p>
<p>尽管基于图像空间的算法在最坏情况下的性能与图元数量成正比; 但z-buffer的性能与光栅化过程生成的片元数量成正比</p>
<ul>
<li><p>扫描线算法结合 shading 和 hsr 隐藏面消除</p>
<ul>
<li><p>扫描线分类: 无遮挡x, y 不需要depth信息;  有遮挡x, y 需要depth信息</p>
</li>
<li><p>伪码 <strong>基于z-buffer的scan-line 算法,  Zx+1,y = -A/C </strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">for each polygon do</div><div class="line">  for each pixel(x, y) in the Polygon's prjection do</div><div class="line">    z = -(D + Ax + By)/c</div><div class="line">    DrawZpixel(x, y, z, polygon's color)</div><div class="line">for each scanline y do</div><div class="line">  for each "in range" polygon projection do</div><div class="line">     for x=x1 to x2 do</div><div class="line">        z =-(D + Ax + By)/c</div><div class="line">        DrawZpixel(x, y, z, polygon's color)</div><div class="line">//如果我们知道在(x,y)处的Zx,y   则Zx+1,y = -A/C</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>openGL实现</p>
<ul>
<li><p>在int main() 设置深度缓冲区测试 <strong>glutInitDisplayMode(GLUT_DEPTH);</strong></p>
</li>
<li><p>打开深度缓冲区测试(在绘图前) <strong>glEnable(GL_DEPTH_TEST)</strong></p>
</li>
<li><p>清除深度缓冲区(在display()开头) <strong>glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);</strong></p>
</li>
<li><p>为了提效, 在后台开启背向面剔除</p>
<p><strong>glEnable(GL_Cull_Face);      glCullFace(GL_BACK);</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="Aliasing-反走样"><a href="#Aliasing-反走样" class="headerlink" title="Aliasing 反走样"></a><strong>Aliasing 反走样</strong></h4><p>代价比较高, 质量变好      理想的光栅化线是1px宽</p>
<p><strong>问题的严重性</strong>: 边缘的锯齿状, 小多边形被忽略, 需要合成一个多边形的颜色不能完全确定pixel的颜色.</p>
<p><strong>反走样解决措施</strong>: 每个x的颜色为多个pixel的混合颜色, 取决于理想线条的覆盖范围, 锯齿状边界变模糊, 颜色混合.</p>
<ul>
<li>开启(慢): glEnable(LINE_SMOOTH);  glEnable(POLYGON_SMOOTH);</li>
<li>关闭(快): glDisable(LINESMOOTH);  glDisable(POLYGON_SMOOTH);</li>
</ul>
<p><strong>时间控制的反走样</strong>  从一个pixel 添加光线追踪线  <strong>移动的物体, 采用随机采样, blue noise</strong></p>
<h3 id="c3-Models-and-Architectures"><a href="#c3-Models-and-Architectures" class="headerlink" title="c3 Models and Architectures"></a><strong>c3 Models and Architectures</strong></h3><h4 id="openGL-流水线以及各个模块功能"><a href="#openGL-流水线以及各个模块功能" class="headerlink" title="openGL 流水线以及各个模块功能"></a><strong>openGL 流水线以及各个模块功能</strong></h4><ul>
<li><p>pipline 整个架构  —— 四个模块(顶点处理, 裁剪和图元装配, 光栅化, 片元处理)</p>
<p><img src="/images/CG/几何绘制流水线.png" alt="几何绘制流水线"> </p>
<ul>
<li>顶点处理: 坐标系之间的变换  以及 顶点颜色的计算  <ul>
<li>对象坐标系/ 建模坐标系</li>
<li>照相机坐标系</li>
<li>屏幕坐标系</li>
</ul>
</li>
<li>裁剪和图元装配<ul>
<li>在裁剪和光栅化之前, 必须进行图元装配—— 将顶点组装成像线段和多边形这样的基本图元(线段, 多边形, 曲线和曲面)</li>
<li>模拟照相机的视角有限, 不在此视见体里的对象被裁出, 此阶段输出的是<strong>一些投影可被成像的图元</strong>                                                                                                                                                                                                                               </li>
</ul>
</li>
<li>光栅化<ul>
<li>如果一个对象未被剪除, 则 frame buffer 中的相应 pixel 必须要分配颜色; <strong>光栅化模块为每个图元输出一组片元</strong>, 片元可看作”潜在像素”, 携带颜色和深度信息. 顶点属性由光栅化模块在对象上插值</li>
</ul>
</li>
<li>片元处理<ul>
<li>利用光栅化模块生成的片元来更新帧缓存中的 pixel . 处理片元以确定帧缓冲器中相应 pixel 的颜色; 颜色可以通过纹理映射或顶点颜色的插值决定, 片元可被离视点更近的遮挡, 隐藏面消除</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="openGL流水线中的坐标系"><a href="#openGL流水线中的坐标系" class="headerlink" title="openGL流水线中的坐标系"></a>openGL流水线中的坐标系</h4><p>绘制流水线的先后顺序:</p>
<ol>
<li>对象坐标系或建模坐标系</li>
<li>世界坐标系</li>
<li>照相机坐标系或眼坐标系</li>
<li>裁剪坐标系</li>
<li>规范化的设备坐标系</li>
<li>窗口坐标系</li>
</ol>
<p>解释:  (每次标架变换都对应一个仿射变换, 均可用4*4矩阵表示)</p>
<ul>
<li><p><strong>对象坐标系</strong> 对象几何中心为原点</p>
</li>
<li><p><strong>世界坐标系</strong> 对每一个对象实施一系列变换(改变大小方向位置),放置一个公共场景</p>
</li>
<li><p><strong>照相机坐标系</strong> 照相机透镜中心</p>
<ul>
<li>照相机坐标系下的三个基向量<ul>
<li>照相机的观察正向—— y 轴正向</li>
<li>照相机正对的方向 —— z轴负向</li>
</ul>
</li>
</ul>
<p><img src="/images/CG/照相机标架.png" alt="照相机标架"></p>
</li>
<li><p><strong>裁剪坐标系</strong> 对象—&gt; camera 坐标系, openGL检查是否位于视见体内, 之外的在光栅化之前就要从场景里裁掉. 为了更有效进行裁剪, openGL 先执行<strong>投影变换</strong>, 这个变换把所有可能是可见的对象变换到一个立方体中, 立方体中心是裁剪坐标系原点</p>
</li>
<li><p><strong>规范化的设备坐标系</strong> 投影变换之后, 顶点的表示仍是齐次坐标. 顶点的齐次坐标表示再<strong>经过透视除法, 即用 w 分量去除其他分量,</strong> 就得到了规范化的设备坐标系下的三维展示.</p>
</li>
<li><p><strong>窗口坐标系</strong>  根据视口提供的信息, 将规范化的设备坐标系下的表示变换为窗口坐标系下的三维表示</p>
</li>
</ul>
<h4 id="openGL窗口坐标系之间的变换"><a href="#openGL窗口坐标系之间的变换" class="headerlink" title="openGL窗口坐标系之间的变换"></a>openGL窗口坐标系之间的变换</h4><p>  图形窗口实现的先后顺序:</p>
<ul>
<li>视图坐标系 —&gt; 视口坐标系 —&gt; 窗口坐标系 —&gt; 屏幕坐标系</li>
<li>除了视图坐标系单位<strong>不</strong>为 pixel 其余均为 pixel</li>
<li><p>视图坐标系原点在 <strong>视图中心</strong>, 屏幕坐标系(<strong>鼠标坐标系</strong>)原点在<strong>左上</strong>, 其余两个原点在<strong>左下</strong></p>
<p>懒得打字, 直接上图</p>
</li>
</ul>
<p><img src="/images/CG/窗口坐标系1.jpeg" alt="窗口坐标系1"></p>
<p><img src="/images/CG/窗口坐标系2.JPG" alt="窗口坐标系2"></p>
<h3 id="C15-Buffers"><a href="#C15-Buffers" class="headerlink" title="C15 Buffers"></a>C15 Buffers</h3><h4 id="Double-Buffering"><a href="#Double-Buffering" class="headerlink" title="Double Buffering"></a>Double Buffering</h4><p>2个颜色缓冲器</p>
<h5 id="front-buffer-前向缓冲器"><a href="#front-buffer-前向缓冲器" class="headerlink" title="front buffer: 前向缓冲器"></a>front buffer: <strong>前向缓冲器</strong></h5><p>只显示不写入</p>
<h5 id="back-buffer-后向缓冲器"><a href="#back-buffer-后向缓冲器" class="headerlink" title="back buffer: 后向缓冲器"></a>back buffer: 后向缓冲器</h5><p>只写入不显示</p>
<p>原理: 显示前向缓冲时, 开始填充后向缓冲;</p>
<p>当后向缓冲器被填充时, 交换两个</p>
<h5 id="openGL-实现"><a href="#openGL-实现" class="headerlink" title="openGL 实现"></a>openGL <strong>实现</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在 main.c 中请求一个双缓冲区</span></div><div class="line">glInitDisplayMode(GL_COLOR | GL_DOUBLE);</div><div class="line"><span class="comment">//在回调函数 display 结束时缓冲区被交换</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</div><div class="line">  glClear(GL_COLOR_BUFFER_BIT | ..);</div><div class="line">  <span class="comment">// 画图</span></div><div class="line">  glutSwapBuffers();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[范数]]></title>
      <url>http://yoursite.com/2017/03/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%91%A8%E4%B9%8B%E8%8C%83%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>机器学习?(ノへ￣、)</p>
<a id="more"></a>
<h4 id="向量范数"><a href="#向量范数" class="headerlink" title="向量范数"></a><strong>向量范数</strong></h4><p>min∑(f(x)-y)^2+正则表达(范数解决过拟合问题)</p>
<ol>
<li><p>L0 特征选择, 非0元素稀疏, 缺点是难优化</p>
</li>
<li><p>L1  可以直接使得元素值为0从而容易稀疏</p>
</li>
<li><p>L2  岭回归  最小化L2范数,可以使得x的元素值都很小, 但都不是0</p>
<p>最小二乘L2范数优化, 凸优化方法</p>
<blockquote>
<p>优点: </p>
<p> 1) 改善”过拟合”overfitting—新样本表现很差(长发问题)</p>
<p>2) 利于优化  机器学习中有时候损失函数是非凸的, 例如: 神经网络, 梯度下降之类的方法遇见</p>
</blockquote>
</li>
</ol>
<h4 id="矩阵范数"><a href="#矩阵范数" class="headerlink" title="矩阵范数"></a><strong>矩阵范数</strong></h4><ol>
<li><p>1-范数  列范数最大 变成向量</p>
</li>
<li><p>2-范数  谱范数 难优化 求特征值</p>
</li>
<li><p>F-范数: (∑i=1,m∑j1,n aij^2)^1/2</p>
<p>最小化矩阵的f范数,会使得矩阵的每个元素都很小,近0</p>
<p>||A-B||F    A,B矩阵尽可能相同 应用字典学习</p>
</li>
<li><p>核范数—-矩阵奇异值的和  </p>
<p>最小化可以导致矩阵低秩  </p>
<p>矩阵的秩—-矩阵线性不相关的行数  去除冗余</p>
<p>不好求所以 近似 是核范数   </p>
<p>应用 推荐系统,低秩  奇异值分解   /鲁棒PCA 重构为低秩+噪声, 不在原始图像上降维</p>
</li>
<li><p>2,1范数 按列求2范数(平方开根)再求1范数, 整列(列向量)稀疏(全0)</p>
<p>Lasso 找出关键词  Group Lasso使一组为0,找出关键句子   Hierarchical Lasso找出关键段</p>
<p>应用:文本分类</p>
</li>
<li><p>1,2范数 按列1(每一列可能有好多0)再2(不稀疏保证了每一列不为0,进而保证了每一列中的每一行不可全为0,平方和开根不为0), 使得行内元素互斥, 行内有0元素但不可能全0</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac Linux文件系统]]></title>
      <url>http://yoursite.com/2016/07/15/mac%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<h3 id="mac-文件系统"><a href="#mac-文件系统" class="headerlink" title="mac 文件系统"></a><strong>mac 文件系统</strong></h3><p>隐藏<br>cmd中ls /</p>
<h4 id="符合unix传统的目录"><a href="#符合unix传统的目录" class="headerlink" title="符合unix传统的目录"></a><strong>符合unix传统的目录</strong></h4><p>/bin 传统unix命令的存放目录，如ls，rm，mv等。<br>/sbin 传统unix管理类命令存放目录，如fdisk，ifconfig等等。<br>/usr 第三方程序安装目录。<br>/usr/bin, /usr/sbin, /usr/lib，其中/usr/lib目录中存放了共享库（动态链接库）.<br>/etc. 标准unix系统配置文件存放目录，如用户密码文件/etc/passwd。此目录实际为指向/private/etc的链接。<br>/dev 设备文件存放目录，如何代表硬盘的/dev/disk0。<br>/tmp 临时文件存放目录，其权限为所有人任意读写。此目录实际为指向/private/tmp的链接。<br>/var 存放经常变化的文件，如日志文件。此目录实际为指向/private/var的链接。</p>
<h4 id="os-x特有的目录"><a href="#os-x特有的目录" class="headerlink" title="os x特有的目录"></a><strong>os x特有的目录</strong></h4><p>/Applications 应用程序目录，默认所有的GUI应用程序都安装在这里；<br>/Library 系统的数据文件、帮助文件、文档等等；<br>/Network 网络节点存放目录；<br>/System 他只包含一个名为Library的目录，这个子目录中存放了系统的绝大部分组件，如各种framework，以及内核模块，字体文件等等。<br>/Users 存放用户的个人资料和配置。每个用户有自己的单独目录。<br>/Volumes 文件系统挂载点存放目录。<br>/cores 内核转储文件存放目录。当一个进程崩溃时，如果系统允许则会产生转储文件。<br>/private 里面的子目录存放了/tmp, /var, /etc等链接目录的目标目录。</p>
<p>OS X发生崩溃和不能启动的概率实在是太低了，就算是系统出现问题，由于用户目录和系统目录是彼此独立的，所以也容易找回。<br>所以通常情况下，用户直接把资料存放在自己的用户目录中</p>
<h3 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h3><p>形式表现上一体——所有数据目录均为根目录下的子目录<br>实质——多个不同的<strong>【逻辑主体】</strong>（为了实现不同的逻辑功能）组合在一起</p>
<h4 id="文件系统结构标准"><a href="#文件系统结构标准" class="headerlink" title="文件系统结构标准"></a><strong>文件系统结构标准</strong></h4><h5 id="LINUX系统的数据文件分类——双重标准"><a href="#LINUX系统的数据文件分类——双重标准" class="headerlink" title="LINUX系统的数据文件分类——双重标准"></a><strong>LINUX系统的数据文件分类——双重标准</strong></h5><p>共享的与独享的（shareable vs. unshareable）<br>数据与平台不相关，如/usr （共享） 数据是平台相关的，如配置数据/etc。变化的和静态的（variable vs. static）<br>相对非管理员用户而言的，没有更变的权限 （静态）</p>
<h5 id="Linux根文件系统逻辑组成"><a href="#Linux根文件系统逻辑组成" class="headerlink" title="Linux根文件系统逻辑组成"></a><strong>Linux根文件系统逻辑组成</strong></h5><p>（以具体目录表现逻辑功能）/ ——根目录（专用的静态的“根本所在”）/usr ——（共享的静态的）/var——（动态的共享的）/opt/home</p>
<h5 id="根目录必选组成目录"><a href="#根目录必选组成目录" class="headerlink" title="根目录必选组成目录"></a><strong>根目录必选组成目录</strong></h5><blockquote>
<p>/bin 基本工具或命令<br>/sbin 系统管理工具或命令<br>/etc 主机相关（Host-speciﬁc）的配置数据<br>/lib 基本共享库和内核模块<br>/dev 设备文件<br>/boot 引导程序<br>/root 管理员的工作目录<br>/mnt 系统管理员的临时挂接点<br>/tmp 系统级临时文件<br>/media 移动设备挂接点</p>
</blockquote>
<h5 id="usr-目录"><a href="#usr-目录" class="headerlink" title="/usr 目录"></a><strong>/usr 目录</strong></h5><p>/usr 目录是系统的一大组成部分，共享的静态的</p>
<p>静态：普通用户不可更改/usr下数据<br>共享：/usr下数据与主机平台不相关，代码独立于运行主机<br>/usr必选组成目录/usr/bin Most user commands<br>/usr/include Header ﬁles included by C programs<br>/usr/blib Libraries<br>/usr/local Local hierarchy (empty after main installation)<br>/usr/sbin Non-vital system binaries<br>/usr/share Architecture-independent data</p>
<h5 id="var目录"><a href="#var目录" class="headerlink" title="/var目录"></a><strong>/var目录</strong></h5><p>/var基本上是动态的和共享的（少量是主机相关的，如/var/log）。<br>/var保存大部分是程序运行期的动态生成数据</p>
]]></content>
    </entry>
    
  
  
</search>
