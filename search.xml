<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[LeetCode1541]]></title>
      <url>http://yoursite.com/2017/03/15/LeetCode%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>好久不碰了,小白求放过…😂</p>
<a id="more"></a>
<h1 id="LeetCode算法刷题过程"><a href="#LeetCode算法刷题过程" class="headerlink" title="LeetCode算法刷题过程"></a><strong>LeetCode算法刷题过程</strong></h1><h3 id="Tag-Arrays-和Hash-1-15"><a href="#Tag-Arrays-和Hash-1-15" class="headerlink" title="Tag: Arrays 和Hash (1,15)"></a><strong>Tag: <code>Arrays</code> 和<code>Hash</code> (1,15)</strong></h3><h4 id="1-twoSum-返回目标值索引"><a href="#1-twoSum-返回目标值索引" class="headerlink" title="1. twoSum 返回目标值索引"></a><strong>1. twoSum 返回目标值索引</strong></h4><blockquote>
<p>本题学习过程帮助我了解vector, unordered_map和map</p>
</blockquote>
<p>我的思路: 先对vector<int>num进行sort排序, 进而头尾相加, 小于target则头指针加一; 大于则只尾指针减一; 等于跳出循环</int></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec(nums);</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result ;</div><div class="line">    sort(nums.begin(), nums.end());</div><div class="line">    <span class="keyword">int</span> a,b,c=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=nums.size()<span class="number">-1</span>; i&lt;=j; i++,j--)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> temp = nums.at(i) + nums.at(j);</div><div class="line">        <span class="keyword">if</span>(temp &lt; target) &#123;j++;&#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(temp &gt; target)&#123;i--;&#125;</div><div class="line">        <span class="keyword">else</span> &#123;a=nums.at(i); b=nums.at(j);<span class="keyword">break</span>;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;vec.size();k++)&#123;</div><div class="line">        <span class="keyword">if</span>(c==<span class="number">2</span>) <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">if</span>(vec.at(k) == a) &#123;result.push_back(k);c++;</div><div class="line">            <span class="keyword">continue</span>;&#125;</div><div class="line">        <span class="keyword">if</span>(vec.at(k) == b) &#123;result.push_back(k);c++;</div><div class="line">            <span class="keyword">continue</span>;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>网上解答</em></p>
<p>Solution/*将n方复杂度的转换为linear, 主要是使用map追踪正确需要的数, 把需要的值存进map</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)&#123;</div><div class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</div><div class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</div><div class="line">    <span class="keyword">int</span> numToFind = target - nums[i];</div><div class="line">    <span class="keyword">if</span>(hash.find(numsToFind) != hash.end())&#123;</div><div class="line">      result.push_back(hash[numsToFind]);</div><div class="line">      result.push_back(i);</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    hash[nums[i]] = i;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####<strong>3.  15. 3Sum</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">报错</div><div class="line">Runtime Error Message: reference binding to null pointer of type &apos;struct value_type&apos;</div><div class="line">原因: 没有验证输入是否为空数组(向量)</div><div class="line">解决:方法里加入if判断</div></pre></td></tr></table></figure>
<p>我的思路:  参照第一题, 先外层遍历i, target=0-nums[i], 在按照第一题的方法去做</p>
<p><strong>问题</strong>: 内层时需要考虑不中间返回, 以及去重问题, 耽误了我的时间复杂度, 😭😭😭</p>
<p>开始      <strong>但是,超时了</strong>妈个叽</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; hash; <span class="comment">//便于追踪正确值, 两个的情况</span></div><div class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; skip; <span class="comment">//存放已测试的num[i],用于跳过</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</div><div class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; repeat;</div><div class="line">        <span class="keyword">if</span> (nums.size() &lt; <span class="number">3</span>)&#123;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size()<span class="number">-2</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (skip.find(nums[i]) != skip.end()) <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">int</span> target = <span class="number">0</span> - nums[i];</div><div class="line">            hash.clear();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++) &#123;</div><div class="line">                <span class="keyword">int</span> numToFind = target - nums[j];</div><div class="line">                <span class="keyword">if</span> (skip.find(nums[j]) != skip.end() || skip.find(numToFind) != skip.end()) <span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">if</span>(hash.find(nums[j]) != hash.end())&#123;</div><div class="line">                    <span class="keyword">if</span>(numToFind != nums[j]) <span class="keyword">continue</span>;</div><div class="line">                    <span class="keyword">if</span>(repeat.find(numToFind) != repeat.end()) <span class="keyword">continue</span>;</div><div class="line">                    repeat.insert(numToFind);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (hash.find(numToFind) != hash.end()) &#123;</div><div class="line">                        tmp.push_back(numToFind);</div><div class="line">                        tmp.push_back(nums[j]);</div><div class="line">                        tmp.push_back(nums[i]);</div><div class="line">                        result.push_back(tmp);</div><div class="line">                        tmp.clear();</div><div class="line">                    &#125;</div><div class="line">                    hash.insert(nums[j]);</div><div class="line">            &#125;</div><div class="line">            skip.insert(nums[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//改成能accepted, 然而复杂度不忍直视😂</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; hash; <span class="comment">//便于追踪正确值, 两个的情况</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp; </div><div class="line">        <span class="keyword">if</span> (nums.size() &lt; <span class="number">3</span>) &#123;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        sort(nums.begin(), nums.end());</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">2</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> ((i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i - <span class="number">1</span>]) || i == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">int</span> target = <span class="number">0</span> - nums[i];</div><div class="line">                hash.clear();</div><div class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</div><div class="line">                <span class="keyword">while</span>(j &lt; nums.size()) &#123;</div><div class="line">                   <span class="keyword">int</span> numToFind = target - nums[j];</div><div class="line">                    <span class="keyword">if</span>(hash.find(numToFind) != hash.end())&#123;</div><div class="line">                        tmp.push_back(numToFind);</div><div class="line">                        tmp.push_back(nums[j]);</div><div class="line">                        tmp.push_back(nums[i]);</div><div class="line">                        result.push_back(tmp);</div><div class="line">                        tmp.clear();</div><div class="line">                        <span class="keyword">while</span>(j &lt; nums.size()<span class="number">-1</span> &amp;&amp; nums[j] == nums[j+<span class="number">1</span>]) j++;</div><div class="line">                        j++;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> hash.insert(nums[j++]);</div><div class="line">               &#125;</div><div class="line">    <span class="comment">//            for(it = hash.begin(); it!=hash.end(); it++)&#123;cout&lt;&lt;*it&lt;&lt;"  ";&#125;</span></div><div class="line">            &#125;</div><div class="line">    <span class="comment">//        cout&lt;&lt;endl;</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>参照网上的答案更改过后:</p>
<p><strong>问题明白两点</strong>    </p>
<ul>
<li>排序,先对给定数组进行排序 </li>
<li>有时, while循环比for循环更好用  优势在于更好的控制每一次 i+1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</div><div class="line">    sort(nums.begin(), nums.end());</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</div><div class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i<span class="number">-1</span>]))&#123;</div><div class="line">            <span class="keyword">int</span> lo = i + <span class="number">1</span>, hi= nums.size() - <span class="number">1</span>, sum = <span class="number">0</span> - nums[i];</div><div class="line">            <span class="keyword">while</span> (lo &lt; hi)&#123;</div><div class="line">              <span class="comment">//第一次允许, 以后通过排序直接跳过可能的重复</span></div><div class="line">                <span class="keyword">if</span> (nums[lo] + nums[hi] ==  sum)&#123;</div><div class="line">                    tmp.push_back(nums[i]);</div><div class="line">                    tmp.push_back(nums[lo]);</div><div class="line">                    tmp.push_back(nums[hi]);</div><div class="line">                    res.push_back(tmp);</div><div class="line">                    tmp.clear();</div><div class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == nums[lo + <span class="number">1</span>]) 					lo++;</div><div class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == nums[hi - <span class="number">1</span>]) 					hi--;</div><div class="line">                    lo++; hi--;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[lo] + nums[hi] &lt; sum) lo++;</div><div class="line">                <span class="keyword">else</span> hi--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>char<em> p = “test”; 这个声明，声明了一个指针，而这个指针指向的是<em>*全局的const内存区</em></em>，const内存区当然不会让你想改就改的。</p>
<h4 id="541-Reverse-String-II"><a href="#541-Reverse-String-II" class="headerlink" title="541.Reverse String II"></a><strong>541.Reverse String II</strong></h4><p>问题描述：一串小写字符，分<k, k<s<2k,="" s="">2k几种情况，每2k个字符第k个逆转到开头,k范围[1, 10000]</k,></p>
<p><strong>小问题</strong>(是我理解的问题还是)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="built_in">string</span> <span class="title">reverseStr</span><span class="params">(String str, <span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>; left&lt;str.size; left+= <span class="number">2</span>*k)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=left,j=min(left+k<span class="number">-1</span>, <span class="keyword">int</span>(s.size()<span class="number">-1</span>)); i&lt;j; i++,j--)</div><div class="line">        &#123;</div><div class="line">          swap(s[i], s[j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CG]]></title>
      <url>http://yoursite.com/2017/03/05/CG%E7%9F%A5%E8%AF%86%E7%82%B9%E9%A2%84%E4%BC%B0%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<h3 id="c11-shading"><a href="#c11-shading" class="headerlink" title="c11 shading"></a><strong>c11 shading</strong></h3><h4 id="phong模型包含-内容"><a href="#phong模型包含-内容" class="headerlink" title="phong模型包含(内容)"></a><strong>phong模型包含(内容)</strong></h4><ul>
<li>环境光, 漫反射, 镜面反射  </li>
<li>公式 四个向量</li>
<li>小细节   <strong>单独求r(反射向量)</strong>  以及  算法改进  <strong>引入H向量</strong> 向量之间计算</li>
<li>增加<strong>衰减因子</strong>(常数项和一次项作用—-当距离变远时, 减缓衰减速度)</li>
</ul>
<h4 id="使用多边形-mash-表示原因"><a href="#使用多边形-mash-表示原因" class="headerlink" title="使用多边形 mash 表示原因"></a><strong>使用多边形 mash 表示原因</strong></h4><ul>
<li>最主要: 可定向求法向, 用于光亮度计算; </li>
<li>可得到边的准确位置, 用于做扫描转换填充</li>
</ul>
<h4 id="phong及Gouraud特点及为什么"><a href="#phong及Gouraud特点及为什么" class="headerlink" title="phong及Gouraud特点及为什么"></a><strong>phong及Gouraud特点及为什么</strong></h4><ul>
<li>两个都是插值着色, G是双插颜色 P是双插法向 (一条边上插值点的法向; 多边形图元之间插边的法向 分离了每一个四角形,中间点可能会出现非垂直的法向)</li>
<li>gouraund 易实现,但未给高亮  (原因 多边形中间很可能存在高光区域, 但是边缘未出现高光)</li>
<li>phong 实现代价比较高, 但有比较好的高亮</li>
<li>使用: 如果表面曲率比较高, phong处理更光滑,但是代价比较高; 均需要数据结构来存储面片, 可以获得点的法向量</li>
</ul>
<h3 id="c12-vertices-to-Fragment-一"><a href="#c12-vertices-to-Fragment-一" class="headerlink" title="c12  vertices to Fragment 一"></a><strong>c12  vertices to Fragment 一</strong></h3><h4 id="关于-pipeline-的过程的具体实施"><a href="#关于-pipeline-的过程的具体实施" class="headerlink" title="关于 pipeline 的过程的具体实施"></a><strong>关于 pipeline 的过程的具体实施</strong></h4><ul>
<li>model —&gt;  Geometric processing (<strong>投影, 图元装配, 剪裁, 着色</strong>) —&gt; Rasterization  —&gt; Fragment processing (<strong>隐藏面消除, 纹理映射, 透明度</strong>)  —&gt; Frame buffer</li>
</ul>
<h4 id="Clipping-算法-内容简述"><a href="#Clipping-算法-内容简述" class="headerlink" title="Clipping 算法 (内容简述)"></a><strong>Clipping 算法 (内容简述)</strong></h4><h5 id="Cohen-Sutherland"><a href="#Cohen-Sutherland" class="headerlink" title="Cohen-Sutherland"></a><strong>Cohen-Sutherland</strong></h5><ul>
<li><p>4种case  重在排除两种 0 内 1 外  y 左 x 右 </p>
</li>
<li><p>理解 </p>
<blockquote>
<p>通过一个矩形的裁剪区域将整个屏幕分成9个部分，并为每一个部分赋予相应的区域码，然后根据端点的位置确定这个端点的区域码。</p>
<p>先判断能否完全接受或者完全排除一条线段，若以上2个判断无法直接得出，则逐步裁剪，选取一个位于裁剪区外的端点，把端点的区域码和裁剪边界的区域码进行逻辑与运算，若结果为真，则端点在该裁剪边界外部，这时将端点移向线段和该边界的交点处，如此循环，直到裁剪结束.</p>
</blockquote>
</li>
<li><p>优 (可排除多数情况; 易扩展至3d 3*9 6bit) 缺 (对于在多个步骤中要裁剪的线段需要多次重复编码,降低效率) 点</p>
</li>
<li><p>normalized form 归一化形式</p>
<ul>
<li>归一化, 中心在原点处,边长为2, 无论定义什么视界体, 对我们来说都是标准化的视界体, 从而不会影响结果.</li>
</ul>
</li>
</ul>
<h5 id="Cyrus-Beck-认为很重要-需要画图考"><a href="#Cyrus-Beck-认为很重要-需要画图考" class="headerlink" title="Cyrus-Beck (认为很重要, 需要画图考)"></a><strong>Cyrus-Beck (</strong>认为很重要, 需要画图考<strong>)</strong></h5><ul>
<li><p>算法简述 参数直线方程 求t= NL(P0-A)/-NL(P1-P0)    <strong>NL(P1-P0)</strong> 作为判断依据  &gt;0 进入点Pe &lt;0 出去点 PL  =0 判断 <strong>NL(P0-A)</strong>正负 (特殊情况)</p>
</li>
<li><p>伪码 了解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>（k edges of clipping polygon）</div><div class="line">&#123;</div><div class="line">    solve Ni·(p1-p0);</div><div class="line">    solve Ni·(p0-Ai);</div><div class="line">    <span class="keyword">if</span> ( Ni·(p1-p0) = = <span class="number">0</span> ) <span class="comment">//parallel with the edge</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> ( Ni·(p0-Ai) &lt; <span class="number">0</span> )</div><div class="line">             <span class="keyword">break</span>; <span class="comment">//invisible</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">             go to next edge;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>  <span class="comment">// Ni·(p1-p0) != 0</span></div><div class="line">    &#123;</div><div class="line">        solve ti;</div><div class="line">        <span class="keyword">if</span> ( Ni·(p1-p0) &lt; <span class="number">0</span> )</div><div class="line">          te = min&#123;<span class="number">1</span>, min&#123;ti| Ni*(P1-P0)&lt;<span class="number">0</span>&#125;&#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">		  tl = max&#123;<span class="number">0</span>, max&#123;ti| Ni*(P1-P0)&gt;<span class="number">0</span>&#125;&#125;</div><div class="line">     &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="Liang-Barsky-梁友栋"><a href="#Liang-Barsky-梁友栋" class="headerlink" title="Liang-Barsky (梁友栋)"></a><strong>Liang-Barsky (梁友栋)</strong></h5><ul>
<li>tL tR tB tT 求解(四个交点) 规律都有一个负号,其余样子一样</li>
<li>画图 裁剪窗口为规则矩形  Rk 和 Sk 的判断</li>
</ul>
<h5 id="三者比较"><a href="#三者比较" class="headerlink" title="三者比较"></a><strong>三者比较</strong></h5><ul>
<li>Cohen-Sutherland: 反复需要裁剪时代价比较高(每次均判断是否需裁); 当大多数线可排除, 只接受一小部分线时最适用</li>
<li>Cyrus-Beck: 计算 t 交点时代价比较低, (x, y) 裁剪点只计算一次; 但是算法不会考虑大部分都不显示的情况,最好是多条线段均需剪裁</li>
<li>Liang-Barsky: Cyrus­Beck的优化版</li>
</ul>
<h5 id="Sutherland-Hodgman-裁剪多边形"><a href="#Sutherland-Hodgman-裁剪多边形" class="headerlink" title="Sutherland-Hodgman (裁剪多边形)"></a><strong>Sutherland-Hodgman (裁剪多边形)</strong></h5><ul>
<li>独立考虑视口的每一条边; 使用边裁剪多边形; 做完所有平面多边形裁剪好   路线: 一次围绕polygon 一个顶点, 以前的s,现在的p 4种case <strong>画图</strong></li>
<li><strong>注意: 凸边形可以但凹变形不可, 可以扩展至3D</strong> </li>
</ul>
<h4 id="Rasterization-—-光栅化-扫描转换"><a href="#Rasterization-—-光栅化-扫描转换" class="headerlink" title="Rasterization — 光栅化, 扫描转换"></a><strong>Rasterization — 光栅化, 扫描转换</strong></h4><p>决定由顶点形成的基本图元包含的pixel; 片元是潜在的像素, 属性包括—位置信息, 颜色, 深度, 纹理坐标等; 片元的位置属性对应于颜色缓存中某个像素的位置。</p>
<h5 id="DDA-线段扫描转换算法"><a href="#DDA-线段扫描转换算法" class="headerlink" title="DDA (线段扫描转换算法)"></a><strong>DDA (线段扫描转换算法)</strong></h5><ul>
<li><p>根据直线斜率确定下一个 pixel 位置, m=△y, 假定0&lt;m&lt;1,  m大于1时,交换x, y</p>
</li>
<li><p>优 (实现容易) 缺 (每一步均涉及浮点运算和四舍五入, 代价比较高)</p>
</li>
<li><p>伪码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=x1; x&lt;=x2; x++)&#123;</div><div class="line">  y+=m; <span class="comment">//m是浮点数</span></div><div class="line">  write_pixel(x, round(y), line_color); <span class="comment">//round()四舍五入</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="Bresenham’s-很重要-画图考"><a href="#Bresenham’s-很重要-画图考" class="headerlink" title="Bresenham’s (很重要, 画图考)"></a><strong>Bresenham’s (</strong>很重要, 画图考<strong>)</strong></h5><ul>
<li><p>基本思想: 假定线段的起点(x1,y1)和终点(x2，y2)的坐标值都是整数, 假定通过计算已经得到了一个位于(i+1/2,j+1/2)位置的像素，该线段所在直线的方程为<br>y=mx+h, 下一个点的候选像素是 (Xi+1, Yi,r +1) 和 (Xi+1 , Yi,r) 引入判定变量 变为一种增量算法  d=△x(a-b), 直接判断B-A就行  Yi+1-Yi,r-0.5<img src="/images/CG/Bresenham.png" alt="Bresenham"></p>
</li>
<li><p><strong>改进(很重要😂, 会画图)</strong></p>
<ul>
<li><p><code>0&lt;m&gt;1</code> 时, 分两种情况: 第二次在第一次的右边;  此时Anew = Alast - m; Bnew =  Blast + m</p>
<p>第二次在第一次右上 Anew = Alast - (m-1);  Bnew =  Blast + (m-1)</p>
</li>
<li><p>伪码, 老师上课要做(重要😁)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bresenham</span><span class="params">(x0, y0, x1, y1)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> dx,dy,x,y,d;</div><div class="line">  dx = x1-x0;</div><div class="line">  dy = y1-y0;</div><div class="line">  d = dx<span class="number">-2</span>*(dy);<span class="comment">//d = △x(a-b)</span></div><div class="line">  x=x0; y=y0;</div><div class="line">  drawpixel(x, y, color);</div><div class="line">  <span class="keyword">while</span>(x&lt;=x1)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">if</span>(d&gt;<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">      x = x + <span class="number">1</span>;</div><div class="line">      y = y;</div><div class="line">      d = d - <span class="number">2</span>*(dy);<span class="comment">//增量  △x(2*m)= 2*△y</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      x = x + <span class="number">1</span>;</div><div class="line">      y = y + <span class="number">1</span>;</div><div class="line">      d = d - <span class="number">2</span>*(dy - dx);<span class="comment">//增量  △x(2*(m-1)= 2*(△y - △x)</span></div><div class="line">    &#125; </div><div class="line">    drawpixel(x, y, color);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="polygon-扫描转换-填充-Fill-奇异点问题注意"><a href="#polygon-扫描转换-填充-Fill-奇异点问题注意" class="headerlink" title="polygon 扫描转换(填充 Fill  奇异点问题注意)"></a><strong>polygon 扫描转换(填充 Fill  </strong>奇异点问题注意<strong>)</strong></h5><p>凸边形 检测点是否在多边形内—奇偶性检测 (奇内偶外), 非凸可能会用winding number (顺时针 交点-1 逆时针 交点+1 不为0 ,则在内)</p>
<ul>
<li>Flood Fill 泛洪单个pixel <ul>
<li>前提: 知道其中的一个种子点, 可以进行递归填充 4/8方向</li>
</ul>
</li>
<li>Flood Fill with scan line 一行<ul>
<li>最主要的 — 找准边界pixel, 可以通过上下行入栈但比较麻烦, 可以通过维护多边形与扫描线的所有交点的数据结构来填充12, 34, 56, 78, 910…</li>
<li><strong>奇异点排除问题</strong>  比较重要 多边形顶点恰在扫描线上.. 解决方式可以是将其中一种裁开,使得交点数量降低; (了解即好—openGL使用了两倍于帧缓存的虚拟缓存,像素中心在整数半值处, 不可能出现奇异点情况)</li>
</ul>
</li>
<li>coherence of scanline   一致性 改进算法, 增量计算<ul>
<li>之前步骤: 找到扫描线和每一条边的交点; 交点排序; 交点之间填充pixel; 缺点: 计算交点很慢</li>
<li>步骤: 利用奇偶性填充, 之前的奇异点必须处理好, 顶点计算两遍的排除.      <strong>难点</strong>: 在于如何快速找到第二条线, 两行扫描线的交点在polygon的同一条边上, 利用扫描线的连续性, <code>Xer = Xdr + 1/mr</code>   <code>△x= 1/m</code>  Xs+1 =  Xs + 1/m</li>
</ul>
</li>
</ul>
<h3 id="c13-Hidden-surface-removal"><a href="#c13-Hidden-surface-removal" class="headerlink" title="c13  Hidden surface removal"></a><strong>c13  Hidden surface removal</strong></h3><p>vertices to Fragment 二</p>
<h4 id="Object-Space方法"><a href="#Object-Space方法" class="headerlink" title="Object Space方法"></a><strong>Object Space方法</strong></h4><p>在polygon对象空间范围使用成对测试, n个多边形最差复杂度O(n^2)</p>
<h5 id="painter’s-算法-Depth-Sort"><a href="#painter’s-算法-Depth-Sort" class="headerlink" title="painter’s 算法 (Depth Sort)"></a><strong>painter’s 算法 (Depth Sort)</strong></h5><ul>
<li>基于对象空间, 先画后面的, 再画前面的 </li>
<li>深度排序 O(nlogn) 如果某个多边形的最小深度值z值大于它后面某个多边形的最大深度值, 先画; 当z值重叠时, 检测x或y的取值范围, 若x, y 不重叠, 则互不遮挡;如果均有重叠, 困难的情况: <ul>
<li>一个polygon的所有顶点均在另一个polygon所在平面的同一侧</li>
<li>3个或更多的polygon循环重叠  <strong>解决办法: 裁开 至少把其中一个多边形分割成两个多边形从而得到一个新多边形集</strong></li>
<li>polygon相互穿透</li>
</ul>
</li>
</ul>
<h4 id="Image-Space方法"><a href="#Image-Space方法" class="headerlink" title="Image Space方法"></a><strong>Image Space方法</strong></h4><p>n*m frame buffer 寻找最近的k个polygons  复杂度O(nmk)</p>
<h5 id="Back-Face-Removal-背向面剔除"><a href="#Back-Face-Removal-背向面剔除" class="headerlink" title="Back-Face Removal 背向面剔除"></a><strong>Back-Face Removal 背向面剔除</strong></h5><ul>
<li>减轻隐藏面清除的计算量, 前向角画背向角不画, 只适用凸边形 glCullFace()</li>
<li>v · n &gt;= 0   [-90, 90]</li>
<li>进一步简化, 归一化之后, 所有的投影为正交投影, v=(0, 0, 1) 平面方程 ax+by+cz+d=0 法向量(a, b, c) 只需考虑c即可</li>
</ul>
<h5 id="Z-Buffer-or-depth-Buffer-算法-增量计算-比较重要"><a href="#Z-Buffer-or-depth-Buffer-算法-增量计算-比较重要" class="headerlink" title="Z-Buffer  or  depth-Buffer 算法   增量计算 比较重要"></a><strong>Z-Buffer  or  depth-Buffer 算法   增量计算 比较重要</strong></h5><p>在图像空间, 初始化全部为∞, 先对多个polygon<strong>光栅化处理</strong>, 对于某个polygon上的每个片元, 它对应于通过某个pixel位置的射线与改多边形的交点, 计算片元到投影中心的距离(即<strong>片元的深度值</strong>), 将片元的深度值同z-buffer相应位置的深度值作比较.</p>
<p>  若前者大, 之前处理的片元离视点更近, 则不可见; 前者小, 则找到离视点更近的一个片元, 使用片元上的深度值更新z-buffer的值, 并把颜色缓存中的相应位置的颜色更新为该片元的颜色.</p>
<ul>
<li><p>注: 从透视投影的角度, 所求得深度值是经过了<strong>归一化变换后的距离</strong>. (虽然是非线性变换, 但相对距离不变)   视界体归一化, 透视投影变成正交投影, 可以利用z值进行深度计算</p>
</li>
<li><p>伪码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//initScreen 初始化</span></div><div class="line"><span class="keyword">for</span> i=<span class="number">0</span> to N <span class="keyword">do</span></div><div class="line">  <span class="keyword">for</span> j=<span class="number">0</span> to N <span class="keyword">do</span></div><div class="line">    screen[i][j] = BackGROUND_COLOR; zbuffer[i][j] = ∞</div><div class="line"><span class="comment">//DrawZpixel(x,y,z,color) 里的xyz经过正交投影归一化</span></div><div class="line"><span class="keyword">if</span>(z &lt; zbuffer[x][y]) then</div><div class="line">  screen[x][y] = color; zbuffer[x][y] = z;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>增量计算</strong> </p>
</li>
</ul>
<p>平面ax+by+cz+d=0 使用扫描线转化光栅化, 深度改变满足 a△x + b△y + c△z = 0 (窗口坐标系) 沿着扫描线 △y=0 △z = -a/c *△x  (△x = 1)  只需计算一次</p>
<p>尽管基于图像空间的算法在最坏情况下的性能与图元数量成正比; 但z-buffer的性能与光栅化过程生成的片元数量成正比</p>
<ul>
<li><p>扫描线算法结合 shading 和 hsr 隐藏面消除</p>
<ul>
<li><p>扫描线分类: 无遮挡x, y 不需要depth信息;  有遮挡x, y 需要depth信息</p>
</li>
<li><p>伪码 <strong>基于z-buffer的scan-line 算法,  Zx+1,y = -A/C </strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">for each polygon do</div><div class="line">  for each pixel(x, y) in the Polygon's prjection do</div><div class="line">    z = -(D + Ax + By)/c</div><div class="line">    DrawZpixel(x, y, z, polygon's color)</div><div class="line">for each scanline y do</div><div class="line">  for each "in range" polygon projection do</div><div class="line">     for x=x1 to x2 do</div><div class="line">        z =-(D + Ax + By)/c</div><div class="line">        DrawZpixel(x, y, z, polygon's color)</div><div class="line">//如果我们知道在(x,y)处的Zx,y   则Zx+1,y = -A/C</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>openGL实现</p>
<ul>
<li><p>在int main() 设置深度缓冲区测试 <strong>glutInitDisplayMode(GLUT_DEPTH);</strong></p>
</li>
<li><p>打开深度缓冲区测试(在绘图前) <strong>glEnable(GL_DEPTH_TEST)</strong></p>
</li>
<li><p>清除深度缓冲区(在display()开头) <strong>glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);</strong></p>
</li>
<li><p>为了提效, 在后台开启背向面剔除</p>
<p><strong>glEnable(GL_Cull_Face);      glCullFace(GL_BACK);</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="Aliasing-反走样"><a href="#Aliasing-反走样" class="headerlink" title="Aliasing 反走样"></a><strong>Aliasing 反走样</strong></h4><p>代价比较高, 质量变好      理想的光栅化线是1px宽</p>
<p><strong>问题的严重性</strong>: 边缘的锯齿状, 小多边形被忽略, 需要合成一个多边形的颜色不能完全确定pixel的颜色.</p>
<p><strong>反走样解决措施</strong>: 每个x的颜色为多个pixel的混合颜色, 取决于理想线条的覆盖范围, 锯齿状边界变模糊, 颜色混合.</p>
<ul>
<li>开启(慢): glEnable(LINE_SMOOTH);  glEnable(POLYGON_SMOOTH);</li>
<li>关闭(快): glDisable(LINESMOOTH);  glDisable(POLYGON_SMOOTH);</li>
</ul>
<p><strong>时间控制的反走样</strong>  从一个pixel 添加光线追踪线  <strong>移动的物体, 采用随机采样, blue noise</strong></p>
<h3 id="c3-Models-and-Architectures"><a href="#c3-Models-and-Architectures" class="headerlink" title="c3 Models and Architectures"></a><strong>c3 Models and Architectures</strong></h3><h4 id="openGL-流水线以及各个模块功能"><a href="#openGL-流水线以及各个模块功能" class="headerlink" title="openGL 流水线以及各个模块功能"></a><strong>openGL 流水线以及各个模块功能</strong></h4><ul>
<li><p>pipline 整个架构  —— 四个模块(顶点处理, 裁剪和图元装配, 光栅化, 片元处理)</p>
<p><img src="/images/CG/几何绘制流水线.png" alt="几何绘制流水线"></p>
<ul>
<li>顶点处理: 坐标系之间的变换  以及 顶点颜色的计算  <ul>
<li>对象坐标系/ 建模坐标系</li>
<li>照相机坐标系</li>
<li>屏幕坐标系</li>
</ul>
</li>
<li>裁剪和图元装配<ul>
<li>在裁剪和光栅化之前, 必须进行图元装配—— 将顶点组装成像线段和多边形这样的基本图元(线段, 多边形, 曲线和曲面)</li>
<li>模拟照相机的视角有限, 不在此视见体里的对象被裁出, 此阶段输出的是<strong>一些投影可被成像的图元</strong>                                                                                                                                                                                                                               </li>
</ul>
</li>
<li>光栅化<ul>
<li>如果一个对象未被剪除, 则 frame buffer 中的相应 pixel 必须要分配颜色; <strong>光栅化模块为每个图元输出一组片元</strong>, 片元可看作”潜在像素”, 携带颜色和深度信息. 顶点属性由光栅化模块在对象上插值</li>
</ul>
</li>
<li>片元处理<ul>
<li>利用光栅化模块生成的片元来更新帧缓存中的 pixel . 处理片元以确定帧缓冲器中相应 pixel 的颜色; 颜色可以通过纹理映射或顶点颜色的插值决定, 片元可被离视点更近的遮挡, 隐藏面消除</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="openGL流水线中的坐标系"><a href="#openGL流水线中的坐标系" class="headerlink" title="openGL流水线中的坐标系"></a>openGL流水线中的坐标系</h4><p>绘制流水线的先后顺序:</p>
<ol>
<li>对象坐标系或建模坐标系</li>
<li>世界坐标系</li>
<li>照相机坐标系或眼坐标系</li>
<li>裁剪坐标系</li>
<li>规范化的设备坐标系</li>
<li>窗口坐标系</li>
</ol>
<p>解释:  (每次标架变换都对应一个仿射变换, 均可用4*4矩阵表示)</p>
<ul>
<li><p><strong>对象坐标系</strong> 对象几何中心为原点</p>
</li>
<li><p><strong>世界坐标系</strong> 对每一个对象实施一系列变换(改变大小方向位置),放置一个公共场景</p>
</li>
<li><p><strong>照相机坐标系</strong> 照相机透镜中心</p>
<ul>
<li>照相机坐标系下的三个基向量<ul>
<li>照相机的观察正向—— y 轴正向</li>
<li>照相机正对的方向 —— z轴负向</li>
</ul>
</li>
</ul>
<p><img src="/Users/yaoyirong/blog/source/images/CG/照相机标架.png" alt="照相机标架"></p>
</li>
<li><p><strong>裁剪坐标系</strong> 对象—&gt; camera 坐标系, openGL检查是否位于视见体内, 之外的在光栅化之前就要从场景里裁掉. 为了更有效进行裁剪, openGL 先执行<strong>投影变换</strong>, 这个变换把所有可能是可见的对象变换到一个立方体中, 立方体中心是裁剪坐标系原点</p>
</li>
<li><p><strong>规范化的设备坐标系</strong> 投影变换之后, 顶点的表示仍是齐次坐标. 顶点的齐次坐标表示再<strong>经过透视除法, 即用 w 分量去除其他分量,</strong> 就得到了规范化的设备坐标系下的三维展示.</p>
</li>
<li><p><strong>窗口坐标系</strong>  根据视口提供的信息, 将规范化的设备坐标系下的表示变换为窗口坐标系下的三维表示</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[范数]]></title>
      <url>http://yoursite.com/2017/03/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%91%A8%E4%B9%8B%E8%8C%83%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>机器学习?(ノへ￣、)</p>
<a id="more"></a>
<h4 id="向量范数"><a href="#向量范数" class="headerlink" title="向量范数"></a><strong>向量范数</strong></h4><p>min∑(f(x)-y)^2+正则表达(范数解决过拟合问题)</p>
<ol>
<li><p>L0 特征选择, 非0元素稀疏, 缺点是难优化</p>
</li>
<li><p>L1  可以直接使得元素值为0从而容易稀疏</p>
</li>
<li><p>L2  岭回归  最小化L2范数,可以使得x的元素值都很小, 但都不是0</p>
<p>最小二乘L2范数优化, 凸优化方法</p>
<blockquote>
<p>优点: </p>
<p> 1) 改善”过拟合”overfitting—新样本表现很差(长发问题)</p>
<p>2) 利于优化  机器学习中有时候损失函数是非凸的, 例如: 神经网络, 梯度下降之类的方法遇见</p>
</blockquote>
</li>
</ol>
<h4 id="矩阵范数"><a href="#矩阵范数" class="headerlink" title="矩阵范数"></a><strong>矩阵范数</strong></h4><ol>
<li><p>1-范数  列范数最大 变成向量</p>
</li>
<li><p>2-范数  谱范数 难优化 求特征值</p>
</li>
<li><p>F-范数: (∑i=1,m∑j1,n aij^2)^1/2</p>
<p>最小化矩阵的f范数,会使得矩阵的每个元素都很小,近0</p>
<p>||A-B||F    A,B矩阵尽可能相同 应用字典学习</p>
</li>
<li><p>核范数—-矩阵奇异值的和  </p>
<p>最小化可以导致矩阵低秩  </p>
<p>矩阵的秩—-矩阵线性不相关的行数  去除冗余</p>
<p>不好求所以 近似 是核范数   </p>
<p>应用 推荐系统,低秩  奇异值分解   /鲁棒PCA 重构为低秩+噪声, 不在原始图像上降维</p>
</li>
<li><p>2,1范数 按列求2范数(平方开根)再求1范数, 整列(列向量)稀疏(全0)</p>
<p>Lasso 找出关键词  Group Lasso使一组为0,找出关键句子   Hierarchical Lasso找出关键段</p>
<p>应用:文本分类</p>
</li>
<li><p>1,2范数 按列1(每一列可能有好多0)再2(不稀疏保证了每一列不为0,进而保证了每一列中的每一行不可全为0,平方和开根不为0), 使得行内元素互斥, 行内有0元素但不可能全0</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python Scrapy]]></title>
      <url>http://yoursite.com/2016/12/15/Python%E5%AD%A6%E4%B9%A0%E4%B9%8BScrapy/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p><strong>简单介绍,之后加上知乎爬虫</strong>.</p>
<a id="more"></a>
<h4 id="概括"><a href="#概括" class="headerlink" title="概括"></a><strong>概括</strong></h4><p>框架优势——提供下载模块, 异步加载, 重点在于提取数据</p>
<p>response和request对象的区别</p>
<p>request是请求，即客服端发来的请求、<br>response是响应，是服务器做出的响应 </p>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h5><ol>
<li>创建一个Scrapy项目</li>
<li>定义提取的Item</li>
<li>编写爬取网站的 <a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/spiders.html#topics-spiders" target="_blank" rel="external">spider</a> 并提取 <a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/items.html#topics-items" target="_blank" rel="external">Item</a></li>
<li>编写 <a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/item-pipeline.html#topics-item-pipeline" target="_blank" rel="external">Item Pipeline</a> 来存储提取到的Item(即数据)</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建Scrapy项目, 注意更换pycharm中的Python源</span></div><div class="line">scrapy startproject tutorial</div><div class="line">scrapy.cfg: 项目的配置文件</div><div class="line">tutorial/: 该项目的python模块。之后您将在此加入代码。可更改</div><div class="line">tutorial/items.py: 项目中的item文件.</div><div class="line">tutorial/pipelines.py: 项目中的pipelines文件.</div><div class="line">tutorial/settings.py: 项目的设置文件.</div><div class="line">tutorial/spiders/: 放置spider代码的目录.</div></pre></td></tr></table></figure>
<h4 id="item部分"><a href="#item部分" class="headerlink" title="item部分"></a><strong>item部分</strong></h4><ol>
<li>item.py  Item容器就是将在网页中获取的数据结构化保存的数据结构，类似于Python中字典</li>
<li><strong>名字(title)，url(link)，以及网站的描述(desc)</strong></li>
<li><strong>Field</strong>一个包含了item所有声明的字段的字典，而不仅仅是获取到的字段。该字典的key是字段(field)的名字，值是 <a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/items.html#topics-items-declaring" target="_blank" rel="external">Item声明</a> 中使用到的 <a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/items.html#scrapy.item.Field" target="_blank" rel="external"><code>Field</code></a> 对象。<a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/items.html#scrapy.item.Field" target="_blank" rel="external"><code>Field</code></a> 对象指明了每个字段的元数据(metadata)。</li>
<li>爬取的主要目标就是从非结构性的数据源提取结构性数据</li>
</ol>
<h4 id="Spider部分"><a href="#Spider部分" class="headerlink" title="Spider部分"></a><strong>Spider部分</strong></h4><ol>
<li>Spider类继承自scrapy.Spider  主要负责爬取和解析数据和url, 具体实现函数大致为 start_requests 以及回调函数(负责接收response处理url, )</li>
<li>meta字典, Scrapy中传递额外数据的方法</li>
<li>unicode中的‘\xa0’字符在转换成gbk(汉字内码扩展规范)编码时会出现问题，gbk无法转换’\xa0’字符。<strong>\xa0是不间断空白符, <code>&amp;nbsp</code></strong>代表空白字符</li>
</ol>
<h4 id="Pipline部分"><a href="#Pipline部分" class="headerlink" title="Pipline部分"></a><strong>Pipline部分</strong></h4><p>当Item在Spider中被收集之后，它将会被传递到Item Pipeline，一些组件会按照一定的顺序执行对Item的处理。</p>
<p><strong>每个item pipeline组件(有时称之为“Item Pipeline”)是实现了简单方法的Python类</strong>。他们接收到Item并通过它执行一些行为，同时也决定此Item是否继续通过pipeline，或是被丢弃而不再进行处理。</p>
<p>以下是item pipeline的一些典型应用：</p>
<ul>
<li>清理HTML数据</li>
<li>验证爬取的数据(检查item包含某些字段)</li>
<li>查重(并丢弃)</li>
<li>将爬取结果保存到数据库中</li>
</ul>
<ol>
<li><p><code>process_item(item, spider)</code>每个item pipeline组件都需要调用该方法，这个方法必须返回一个 <a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/items.html#scrapy.item.Item" target="_blank" rel="external"><code>Item</code></a> (或任何继承类)对象， 或是抛出 <a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/exceptions.html#scrapy.exceptions.DropItem" target="_blank" rel="external"><code>DropItem</code></a> 异常，被丢弃的item将不会被之后的pipeline组件所处理。</p>
</li>
<li><p><code>open_spider(spider)</code></p>
<p>当spider被开启时，这个方法被调用。</p>
</li>
<li><p><code>close_spider(*spider*)</code></p>
<p>当spider被关闭时，这个方法被调用.</p>
<h4 id="将item写入JSON文件"><a href="#将item写入JSON文件" class="headerlink" title="将item写入JSON文件"></a><strong>将item写入JSON文件</strong></h4><p>pipeline将所有(从所有spider中)爬取到的item，存储到一个独立地 <code>items.jl</code> 文件，每行包含一个序列化为JSON格式的item:</p>
<p>​</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python 语法补充]]></title>
      <url>http://yoursite.com/2016/12/14/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E6%B3%95%E8%A1%A5%E5%85%85/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p><strong>一点零碎小知识</strong>.</p>
<a id="more"></a>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a><strong>打开文件</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    f = open(<span class="string">'xxxxx'</span>)</div><div class="line"><span class="keyword">except</span>:</div><div class="line">    print(<span class="string">'fail to open'</span>)</div><div class="line">    exit(<span class="number">-1</span>)</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    do something</div><div class="line"><span class="keyword">except</span>:</div><div class="line">    do something</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    f.close()//防止程序抛出异常最后不能关闭文件</div><div class="line">//另一个</div><div class="line"><span class="keyword">try</span>:</div><div class="line">	f = open(“file”, “r”)</div><div class="line"><span class="keyword">try</span>:</div><div class="line">	line = f.readline()</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">	f.close()</div><div class="line"><span class="keyword">except</span> IOError:</div><div class="line">	print(“bad”)</div></pre></td></tr></table></figure>
<h3 id="with-as-结构-确保异常可关闭"><a href="#with-as-结构-确保异常可关闭" class="headerlink" title="with ..  as ..结构  确保异常可关闭"></a><strong>with ..  as ..结构</strong>  <strong>确保异常可关闭</strong></h3><p>过程: with语句跳转<code>__enter__</code>函数, 返回值给as后的变量, 运行do sth , 最后跳转至<code>__exit__</code>函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">controlled_execution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></div><div class="line">        set things up</div><div class="line">        <span class="keyword">return</span> thing</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, type, value, traceback)</span>:</span></div><div class="line">        tear things down</div><div class="line">      </div><div class="line"><span class="keyword">with</span> open(<span class="string">'x.txt'</span>) <span class="keyword">as</span> f:</div><div class="line">    data = f.data()</div><div class="line">    do sth</div></pre></td></tr></table></figure>
<p><strong>exit</strong>除了用于tear things down，还可以进行异常的监控和处理，注意后几个参数。要跳过一个异常，只需要返回该函数True即可。下面的样例代码跳过了所有的TypeError，而让其他异常正常抛出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, type, value, traceback)</span>:</span></div><div class="line">    <span class="keyword">return</span> isinstance(value, TypeError)</div></pre></td></tr></table></figure>
<h3 id="迭代器-iterator-和生成器-generator"><a href="#迭代器-iterator-和生成器-generator" class="headerlink" title="迭代器 iterator 和生成器 generator"></a><strong>迭代器 iterator 和生成器 generator</strong></h3><p>实现迭代器协议, 有next方法的对象会前进到下一结果, 直到引发StopIteration结束, 在Python中有迭代器对象都可以使用for循环遍历, 好处是每次只从对象中读取一条数据，不会造成内存的过大开销(不是一次性加载到内存中)。</p>
<p>特点: yield</p>
<p>不像一般的函数生成值后会退出, 生成函数在生成值后会自动挂起并暂停它们的执行和状态, 它的本地变量将保存状态信息, 这些信息在函数恢复时会再度有效</p>
<p>可以简单地把列表生成式改成generator，也可以通过函数实现复杂逻辑的generator。工作原理，在<code>for</code>循环的过程中不断计算出下一个元素，并在适当的条件结束<code>for</code>循环。对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句，就是结束generator的指令，<code>for</code>循环随之结束。</p>
<p>包含yield语句的是生成器函数, 其执行流程如下 :</p>
<p>每次调用<code>next</code>时执行, 遇到<code>yield</code>停止, 下次再调用next时, 从yield停止处继续 .使用时直接调用for循环即可<code>for n in filb(5): print n</code>.</p>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a><strong>切片</strong></h3><p>a[start, end, step]带步进值的</p>
<p><strong>正序索引（0，i-1）倒序索引（-1，-i）</strong></p>
<p><code>step &gt; 0: start —&gt; end</code> ( 不含 end ) 从左往右, 相隔元素 step - 1 (索引值差 step ), 若 start 位于 end 右边, 返回空<br><code>step &lt; 0: start -&gt; end</code> (不含 end ) 从右到左, 相隔元素 step-1 (索引值差step ),若 start 位于 end 左边, 返回空<br>翻转字符串 <code>[::-1]</code> </p>
<h3 id="Python模块之BeautifulSoup及HTML解析器"><a href="#Python模块之BeautifulSoup及HTML解析器" class="headerlink" title="Python模块之BeautifulSoup及HTML解析器 "></a><strong>Python模块之BeautifulSoup及HTML解析器 </strong></h3><p>soup.title.name   title      soup.title.string  具体名字</p>
<p>所有HTML均是对象, 四种对象Tag(标签) , NavigableString(string) , BeautifulSoup(类似tag 但无name和atter属性), Comment</p>
<p><strong>find_all取出来是以列表形式存在,不用for循环无法继续find</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">解析器</th>
<th style="text-align:center">使用方法</th>
<th style="text-align:center">优势</th>
<th style="text-align:center">劣势</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Python标准库</td>
<td style="text-align:center">BeautifulSoup(markup, “html.parser”)</td>
<td style="text-align:center">Python的内置标准库执行速度适中文档容错能力强</td>
<td style="text-align:center">Python 2.7.3 or 3.2.2)前 的版本中文档容错能力差</td>
</tr>
<tr>
<td style="text-align:center">lxml HTML 解析器</td>
<td style="text-align:center">BeautifulSoup(markup, “lxml”)</td>
<td style="text-align:center">速度快文档容错能力强</td>
<td style="text-align:center">需要安装C语言库</td>
</tr>
<tr>
<td style="text-align:center">lxml XML 解析器</td>
<td style="text-align:center">BeautifulSoup(markup, [“lxml”, “xml”])BeautifulSoup(markup, “xml”)</td>
<td style="text-align:center">速度快唯一支持XML的解析器</td>
<td style="text-align:center">需要安装C语言库</td>
</tr>
<tr>
<td style="text-align:center">html5lib</td>
<td style="text-align:center">BeautifulSoup(markup, “html5lib”)</td>
<td style="text-align:center">最好的容错性以浏览器的方式解析文档生成HTML5格式的文档</td>
<td style="text-align:center">速度慢不依赖外部扩展</td>
</tr>
</tbody>
</table>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a><strong>回调函数</strong></h3><blockquote>
<p>回调函数就是一个通过<strong>函数指针</strong>调用的函数。如果你把函数的指针(地址)作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是<strong>在特定的事件或条件发生</strong>时由另外的一方调用的，用于<strong>对该事件或条件进行响应</strong>。</p>
</blockquote>
<p>软件模块之间总是存在一定接口, 调用方式上可分3类: </p>
<ul>
<li>同步调用(阻塞式调用,等待对方执行完毕才返回, 单向调用)</li>
<li>异步调用(类似消息或事件的机制——接口的服务在收到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）</li>
<li>回调(双向调用模式——回调函数被调用方在接口被调用的时候也会调用对方的接口)</li>
</ul>
<p>回调和异步调用的关系非常紧密，通常我们使用回调来实现<strong>异步消息的注册</strong>，通过异步调用来实现<strong>消息的通知</strong>。</p>
<p>回调常常是异调的基础</p>
<h3 id="json格式"><a href="#json格式" class="headerlink" title="json格式"></a><strong>json格式</strong></h3><p>dumps() 是将 dict 转化成 str 格式，loads() 是将 str 转化成 dict 格式。</p>
<p>dump 和 load 也是类似的功能，只是与文件操作结合起来了</p>
<p>简单说就是dump需要一个类似于文件指针的参数（并不是真的指针，可称之为类文件对象），可以与文件操作结合，也就是说可以将 dict 转成 str 然后存入文件中；而 dumps 直接给的是 str，也就是将字典转成str。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> json</div><div class="line">a =&#123;<span class="string">"name"</span>: <span class="string">"wang"</span>&#125;</div><div class="line">fp = open(<span class="string">'test.txt'</span>,<span class="string">'w'</span>)</div><div class="line">json.dump(a, fp)</div><div class="line">fp.close()</div></pre></td></tr></table></figure>
<h3 id="assert—断言"><a href="#assert—断言" class="headerlink" title="assert—断言"></a><strong>assert—断言</strong></h3><p>在没完善一个程序之前，我们不知道程序在哪里会出错，与其让它在运行时崩溃，不如在出现错误条件时就崩溃，这时候就需要 assert 断言的帮助. assert 断言语句为 raise-if-not，用来测试表示式，其返回值为假，就会触发异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#可为断言添加异常参数,用于解释 assert expression [, arguments]</span></div><div class="line"><span class="keyword">assert</span> len(lists) &gt;=<span class="number">5</span>,<span class="string">'列表元素个数小于5'</span></div><div class="line"><span class="keyword">assert</span> <span class="number">2</span>==<span class="number">1</span>,<span class="string">'2不等于1'</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[STL学习]]></title>
      <url>http://yoursite.com/2016/11/14/STL(Standard%C2%A0Template%C2%A0Library)%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>🙉🙉, 我要做好好读书的好巨婴, 恩!</p>
<a id="more"></a>
<h1 id="STL-Standard-Template-Library-学习"><a href="#STL-Standard-Template-Library-学习" class="headerlink" title="STL(Standard Template Library)学习"></a><strong>STL(Standard Template Library)学习</strong></h1><h2 id="读-lt-lt-Effective-STL-gt-gt"><a href="#读-lt-lt-Effective-STL-gt-gt" class="headerlink" title="读&lt;&lt;Effective STL&gt;&gt;"></a><strong>读&lt;<code>&lt;Effective STL&gt;</code>&gt;</strong></h2><h3 id="导论"><a href="#导论" class="headerlink" title="导论"></a><strong>导论</strong></h3><blockquote>
<p>导论:</p>
<p>本书中的”STL” —与<strong>迭代器</strong>合作的 c++ 标准库的一部分.包括标准容器(包括  string) , iostream 库</p>
</blockquote>
<h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a><strong>术语</strong></h4><p><strong>迭代器的类型:</strong></p>
<ul>
<li>输入迭代器(每个迭代位置只能被读一次的只读迭代器, 通常表现为istream_iterator )</li>
<li>输出迭代器(每个迭代位置只能被写一次的只写迭代器, 通常表现为ostream_iterator )</li>
<li>前向迭代器(有输入和输出迭代器的能力, 但可反复读或写一个位置,  不支持operator-, 所以可以高效地向前移动任意次数)  (单链表\散列可提供)  </li>
<li>双向迭代器(类似前向迭代器, 但后退可以像前进一样容易)(标准关联容器都提供)</li>
<li>随机访问迭代器(做双向迭代一切事情，但它们也提供“ 迭代算术” ，即，有一步向前或向后跳的能 力。vector、string 和deque 都提供随机访问迭代 。指进数组的指针可以作为数组的随机访问迭代 。)             </li>
</ul>
<p>STL包括五大类组件：算法 algorithm、容器、迭代器 iterator、函数对象、适配器</p>
<p>序列强调值的排序, 关联式强调值的关键字和索引</p>
<ul>
<li>标准STL序列容器: vector、string、deque和list</li>
<li>标准STL关联容器: set、multiset、map和multimap。</li>
<li>非标准序列容器 slist和 rope。</li>
<li>非标准关联容器 hash_set、hash_multiset、hash_map 和 hash_multimap。</li>
<li>几种标准非STL容器，包括数组、bitset、valarray、stack、queue和priority_queue。</li>
</ul>
<h3 id="the-first-仔细选择你的容器"><a href="#the-first-仔细选择你的容器" class="headerlink" title="the first: 仔细选择你的容器"></a><strong>the first: 仔细选择你的容器</strong></h3><h4 id="vector-list-deque选择"><a href="#vector-list-deque选择" class="headerlink" title="vector, list, deque选择"></a><strong>vector, list, deque选择</strong></h4><p>vector、list和deque提供给程序员不同的复杂度，因此应该这么用:vector是一种可以默认使用的序列类型(<strong>对尾部的插入和删除, 对数据的访问</strong>)，当很频繁地对<strong>序列中部</strong>进行插入和删除时应该用list，当大部分<strong>插入和删除发生在序列的头或尾</strong>时可以选择deque这种数据结构.</p>
<h4 id="STL容器的分类方法"><a href="#STL容器的分类方法" class="headerlink" title="STL容器的分类方法"></a><strong>STL容器的分类方法</strong></h4><ul>
<li><p>连续内存容器(基于array的容器)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">在一个或多个(动态分配)的内存块中保存它们的元素。如果一个新元素被插入或者已存元素被删除，其他在同一个内存块的元素就必须向上或者向下移动来为新元素提供空间或者填充原来被删除的元素所占的空间。这种移动影响了效率和异常安全.</div><div class="line">标准的连续内存容器是vector、string和deque。非标准的rope也是连续内存容器.</div></pre></td></tr></table></figure>
</li>
<li><p>基于节点的容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">在每个内存块(动态分配)中只保存一个元素。容器元素的插入或删除只影响指向节点的指针，而不是节点自己的内容。所以当有东西插入或删除时，元素值不需要移动。</div><div class="line">表现为链表的容器——比如 list 和 slist ——是基于节点的，所有的标准关联容器也是(它们的典型实现是平衡树)。</div><div class="line">非标准的散列容器使 用不同的基于节点的实现.</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[网络相关背景]]></title>
      <url>http://yoursite.com/2016/11/05/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E8%83%8C%E6%99%AF/</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<h3 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a><strong>相关名词</strong></h3><h4 id="网线和网卡"><a href="#网线和网卡" class="headerlink" title="网线和网卡"></a><strong>网线和网卡</strong></h4><p>网线：即双绞线(twisted pair，TP)，是一种综合布线工程中最常用的传输介质，<strong>传输信号</strong><br>网卡：网卡是工作在<strong>数据链路层</strong>的网络组件，是<strong>局域网</strong>中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。<strong>平台，发射和接收信号</strong><br>PS:现在大多数的笔记本电脑里内置了有线网卡和无线网卡，即<strong>以太网适配器</strong><br>有线网卡需要用网线连接后加入局域网，无线网卡可以通过无线传输来更便捷的接入局域网。</p>
<h4 id="IP地址-IPv4"><a href="#IP地址-IPv4" class="headerlink" title="IP地址(IPv4)"></a><strong>IP地址(IPv4)</strong></h4><p>4个8位二进制数表示的定位网络位置的方法，一般我们把它转换成<strong>4段十进制数字</strong></p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a><strong>子网掩码</strong></h4><p>也是32位二进制数，规则是前面必须是连续的1，表示网络位，后面为连续的0，表示主机位。255.255.255.224<br>子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。</p>
<h4 id="默认网关"><a href="#默认网关" class="headerlink" title="默认网关"></a><strong>默认网关</strong></h4><p>一个用于 TCP/IP 协议的配置项，是一个可直接到达的 IP 路由器的 IP 地址<br>配置默认网关可以在 IP 路由表中创建一个默认路径</p>
<h3 id="TCP-IP协议——网络通信的标准协议"><a href="#TCP-IP协议——网络通信的标准协议" class="headerlink" title="TCP/IP协议——网络通信的标准协议"></a><strong>TCP/IP协议——网络通信的标准协议</strong></h3><p>网络服务<a href="http://baike.baidu.com/link?url=zgUQnV0noG6bj70pn6uzjHcxkSjp-gIhMO04fMZ69yPL3D_WlCy2vDDlmCN2iwh0m-ifrm8thMwmv-olVoIJUK" target="_blank" rel="external">链接</a><br>服务器端口<a href="http://baike.baidu.com/link?url=Eod5R06EATtFkqc45akcT88sqNx6vD6UpZkz6HBtM6OPvGbxPHyvb03GZ7aTyrTqkIu_XDXPNH1mMp12N0VcA_#3_8" target="_blank" rel="external">链接</a></p>
<h4 id="解决物理接口问题"><a href="#解决物理接口问题" class="headerlink" title="解决物理接口问题"></a><strong>解决物理接口问题</strong></h4><blockquote>
<p>TCP/IP协议集成到操作系统的内核，相当于在操作系统中引入了一种新的输入/输出接口技术，<br>因为在TCP/IP协议中引入了一种称之为”Socket（套接字）”应用程序接口。<br>一台计算机就可以通过软件的方式与任何一台具有Socket接口的计算机进行通信</p>
</blockquote>
<h4 id="端口分类"><a href="#端口分类" class="headerlink" title="端口分类"></a><strong>端口分类</strong></h4><ul>
<li><h5 id="根据参考对象不同"><a href="#根据参考对象不同" class="headerlink" title="根据参考对象不同"></a><strong>根据参考对象不同</strong></h5><p>1）公认端口（Well Known Ports）：<strong>0到1023</strong>紧密绑定特定的服务，不可重定义<br>2）注册端口（Registered Ports）：<strong>1024到49151</strong>松散绑定于某些服务，<br>这些端口多数没有明确的定义服务对象，不同程序可根据实际需要自己定义<br>3）动态和/或私有端口（Dynamic and/or Private Ports）：<strong>9152到65535</strong></p>
</li>
<li><h5 id="根据所提供的服务方式的不同——两种通信协议"><a href="#根据所提供的服务方式的不同——两种通信协议" class="headerlink" title="根据所提供的服务方式的不同——两种通信协议"></a><strong>根据所提供的服务方式的不同——两种通信协议</strong></h5><p>TCP—–”连接方式”是一种直接与接收方进行的连接，发送信息以后，可以确认信息是否到达<br>UDP——“无连接方式”不是直接与接收方进行连接，只管把信息放在网上发出去，而不管信息是否到达，<br>1）TCP协议端口：<br>i. FTP—定义了文件传输协议，使用21端口。<br>ii. Telnet—用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上,通过这种端口可以提供一种基于DOS模式下的通信服务<br>iii. SMTP—–定义了简单邮件传送协议，很多邮件服务器都用的是这个协议，用于发送邮件。25端口<br>iv.POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Foxmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件<br>2）UDP协议端口：</p>
</li>
</ul>
<h4 id="网络服务、端口、协议"><a href="#网络服务、端口、协议" class="headerlink" title="网络服务、端口、协议"></a><strong>网络服务、端口、协议</strong></h4><p>TCP/IP协议定义了不同端口，用于支持不同的服务各种服务采用不同的端口提供不同的服务 比如：通常TCP/IP协议规定Web采用80号端口，FTP采用21号端口等，而邮件服务器是采用25号端口。通过不同端口，pc可以与外界进行互不干扰的通信.</p>
<p>与网络相关的Dos命令</p>
<p>ping命令——<strong>Ping空格IP地址</strong>也属于一个通信协议，<br>用来检查网络是否通畅或者网络连接速度的命令</p>
<h4 id="HTTP相关"><a href="#HTTP相关" class="headerlink" title="HTTP相关"></a><strong>HTTP相关</strong></h4><ul>
<li>http客户端发起请求, 创建端口.</li>
<li>http服务器在端口监听客户端请求</li>
<li>http服务器向客户端返回状态和内容</li>
<li>查看曾经浏览过的DNS缓存记录</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c++ map篇]]></title>
      <url>http://yoursite.com/2016/10/16/map%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><blockquote>
<p>c++11加入unordered_map, 类似map, 存储key-value值, </p>
<p>Map 键值对应容器, map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。</p>
</blockquote>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a><strong>基础</strong></h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><p><code>map&lt;string,   int&gt;   my_Map;</code></p>
<h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my_Map[<span class="string">'a'</span>] = <span class="number">1</span>;</div><div class="line">my_Map.insert(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::value_type(<span class="string">"b"</span>, <span class="number">2</span>));</div><div class="line">my_Map.insert(pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;(<span class="string">"c"</span>, <span class="number">3</span>))</div><div class="line">my_Map.insert(make_pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;(<span class="string">"d"</span>,<span class="number">4</span>));</div></pre></td></tr></table></figure>
<h4 id="查询和修改数据"><a href="#查询和修改数据" class="headerlink" title="查询和修改数据"></a><strong>查询和修改数据</strong></h4><p>(键本身是不能被修改的，除非删除)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = my_Map[<span class="string">"a"</span>];</div><div class="line">my_Map[<span class="string">"a"</span>] = i;</div><div class="line">MY_MAP::iterator my_Itr;</div><div class="line">my_Itr.find(<span class="string">"b"</span>);</div><div class="line"><span class="keyword">int</span> j = my_Itr-&gt;second;</div><div class="line">my_Itr-&gt;second = j;</div></pre></td></tr></table></figure>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a><strong>删除数据</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my_Map.erase(my_Itr);<span class="comment">//在迭代期间是不能被删除的，道理和foreach时不能删除元素一样。 </span></div><div class="line">my_Map.erase(<span class="string">"c"</span>)</div></pre></td></tr></table></figure>
<h4 id="迭代数据"><a href="#迭代数据" class="headerlink" title="迭代数据"></a><strong>迭代数据</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(my_Itr=my_Map.begin();my_Itr!=my_Map.end();++myItr)&#123;&#125;</div></pre></td></tr></table></figure>
<h4 id="other"><a href="#other" class="headerlink" title="other"></a><strong>other</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my_Map.size()        返回元素数目 </div><div class="line">my_Map.empty()       判断是否为空 </div><div class="line">my_Map.clear()       清空所有元素</div></pre></td></tr></table></figure>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a><strong>进阶</strong></h3><h4 id="关于hash-map介绍"><a href="#关于hash-map介绍" class="headerlink" title="关于hash_map介绍"></a><strong>关于hash_map介绍</strong></h4><p>map提供key-value的存储和查找功能, 并且实现的效率比较高; 100万条记录，最多也只要20次的string.compare的比较，就能找到你要找的记录;200万条记录事，也只要用21次的比较。</p>
<p>对于速度的追求使得hash_map诞生. hash_map基于hash table（哈希表)—<strong>哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；编码也比较容易.而代价仅仅是消耗比较多的内存。</strong>“直接定址”与“解决冲突”是哈希表的两大特点。 </p>
<p>插入: key—&gt;hash值—&gt;桶号—&gt;桶内存key和value</p>
<p>取值(查找): key—&gt;hash值—&gt;桶号—&gt;比较桶内key值是否等</p>
<p><code>if(myhash_map.find(key)) != myhash_map.end()</code> 表示查找key成功</p>
<h4 id="hash函数-和-比较函数"><a href="#hash函数-和-比较函数" class="headerlink" title="hash函数 和 比较函数"></a><strong>hash函数</strong> 和 <strong>比较函数</strong></h4><p>很多类型如int等是有默认的hash函数的, 但像string这种没有, 需要自定义.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*---例如---*/</span></div><div class="line"><span class="keyword">struct</span> str_hash&#123;</div><div class="line">  <span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)<span class="keyword">const</span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> __h = <span class="number">0</span>; </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span> ; i &lt; str.size() ; i ++) </div><div class="line">      __h = <span class="number">5</span>*__h + str[i]; </div><div class="line">    <span class="keyword">return</span> <span class="keyword">size_t</span>(__h); </div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//如果你希望利用系统定义的字符串hash函数</span></div><div class="line"><span class="keyword">struct</span> str_hash&#123;</div><div class="line">  <span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="built_in">string</span>&amp;str)<span class="keyword">const</span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">return</span> __stl_hash_string(str.c_str());</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>可迭代对象：对象里面包含<strong>iter()</strong>方法的实现，对象的iter函数经调用之后会返回一个迭代器，里面包含具体数据获取的实现。</li>
<li>迭代器：包含有next方法的实现，在正确范围内返回期待的数据以及超出范围后能够抛出StopIteration的错误停止迭代。</li>
</ul>
<h4 id="此次"><a href="#此次" class="headerlink" title="此次"></a><strong>此次</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">list</span></div><div class="line"><span class="built_in">string</span></div><div class="line">t = iter(<span class="built_in">string</span>);</div><div class="line">For tt in t</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c++ vector篇]]></title>
      <url>http://yoursite.com/2016/10/01/c++%E5%AD%A6%E4%B9%A0%E4%B9%8Bvector%E7%AF%87/</url>
      <content type="html"><![CDATA[<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><p>对比array , vetor 消耗更多内存交换管理以及有效增长存储能力</p>
<p>efficient      访问元素(array), 从 end 添加删除元素</p>
<p>worse    非end添加删除元素, </p>
<p>less consistent iterators 相对于lists 和 forward_lists</p>
<p>The container uses an allocator object to dynamically handle its storage needs.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">c++ vector里的allocator</div><div class="line">内存池分配器, 管理了一段内存, 允许在他管理的内存上分配内存, 便于清楚了解在哪分配\使用\释放内存</div><div class="line">有时候, 对内存分配会有特别的要求，比如同一个类型分在一起，或者有特别的优化算法。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>``` 随时自动调整自身的大小以便容下所要放入的元素</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### **声明及初始化**</div><div class="line"></div><div class="line">```c++</div><div class="line">vector &lt;int&gt;a;</div><div class="line">vector &lt;int&gt;a(10);</div><div class="line">vector &lt;int&gt;a(b);</div><div class="line">vector &lt;int&gt;a(b.begin(),b.begin()+3)</div><div class="line">int n=[1,2,3,4,5];</div><div class="line">vector &lt;int&gt;a(n, n+5);</div><div class="line">vector &lt;int&gt;a(&amp;n[1], &amp;n[4])   //n1-n4范围</div></pre></td></tr></table></figure>
<h4 id="输入及访问"><a href="#输入及访问" class="headerlink" title="输入及访问"></a><strong>输入及访问</strong></h4><h4 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器 iterator"></a><strong>迭代器 iterator</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;:: iterator t;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t= vec.begin(); t != vec.end(); t++)&#123;</div><div class="line">  <span class="built_in">cout</span>&lt;&lt; *t &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="删除vector的内存空洞"><a href="#删除vector的内存空洞" class="headerlink" title="删除vector的内存空洞"></a><strong>删除vector的内存空洞</strong></h4><ul>
<li><p>erase()函数，只能删除内容，不能改变容量大小；</p>
<p>erase成员函数，它删除了itVect迭代器指向的元素，并且返回要被删除的itVect之后的迭代器，迭代器相当于一个智能指针。</p>
</li>
<li><p>clear()函数，只能清空内容，不能改变容量大小</p>
<p>vector容器删除不自动释放内存，那么它存在内存泄露？？？不是的，vector在析构函数的时候，对内存进行了释放。</p>
</li>
<li><p>如果要想在删除内容的同时释放内存，那么你可以选择<strong>deque</strong>容器。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>(v).swap(v);将v的内存空洞清除</div><div class="line"><span class="built_in">vector</span>().swap(v);清空vec</div></pre></td></tr></table></figure>
<p>vector的元素不仅仅可以是int,double,string,还可以是<strong>结构体</strong>，但是要注意：结构体要定义为全局的，否则会出错。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac Linux文件系统]]></title>
      <url>http://yoursite.com/2016/07/15/mac%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<h3 id="mac-文件系统"><a href="#mac-文件系统" class="headerlink" title="mac 文件系统"></a><strong>mac 文件系统</strong></h3><p>隐藏<br>cmd中ls /</p>
<h4 id="符合unix传统的目录"><a href="#符合unix传统的目录" class="headerlink" title="符合unix传统的目录"></a><strong>符合unix传统的目录</strong></h4><p>/bin 传统unix命令的存放目录，如ls，rm，mv等。<br>/sbin 传统unix管理类命令存放目录，如fdisk，ifconfig等等。<br>/usr 第三方程序安装目录。<br>/usr/bin, /usr/sbin, /usr/lib，其中/usr/lib目录中存放了共享库（动态链接库）.<br>/etc. 标准unix系统配置文件存放目录，如用户密码文件/etc/passwd。此目录实际为指向/private/etc的链接。<br>/dev 设备文件存放目录，如何代表硬盘的/dev/disk0。<br>/tmp 临时文件存放目录，其权限为所有人任意读写。此目录实际为指向/private/tmp的链接。<br>/var 存放经常变化的文件，如日志文件。此目录实际为指向/private/var的链接。</p>
<h4 id="os-x特有的目录"><a href="#os-x特有的目录" class="headerlink" title="os x特有的目录"></a><strong>os x特有的目录</strong></h4><p>/Applications 应用程序目录，默认所有的GUI应用程序都安装在这里；<br>/Library 系统的数据文件、帮助文件、文档等等；<br>/Network 网络节点存放目录；<br>/System 他只包含一个名为Library的目录，这个子目录中存放了系统的绝大部分组件，如各种framework，以及内核模块，字体文件等等。<br>/Users 存放用户的个人资料和配置。每个用户有自己的单独目录。<br>/Volumes 文件系统挂载点存放目录。<br>/cores 内核转储文件存放目录。当一个进程崩溃时，如果系统允许则会产生转储文件。<br>/private 里面的子目录存放了/tmp, /var, /etc等链接目录的目标目录。</p>
<p>OS X发生崩溃和不能启动的概率实在是太低了，就算是系统出现问题，由于用户目录和系统目录是彼此独立的，所以也容易找回。<br>所以通常情况下，用户直接把资料存放在自己的用户目录中</p>
<h3 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h3><p>形式表现上一体——所有数据目录均为根目录下的子目录<br>实质——多个不同的<strong>【逻辑主体】</strong>（为了实现不同的逻辑功能）组合在一起</p>
<h4 id="文件系统结构标准"><a href="#文件系统结构标准" class="headerlink" title="文件系统结构标准"></a><strong>文件系统结构标准</strong></h4><h5 id="LINUX系统的数据文件分类——双重标准"><a href="#LINUX系统的数据文件分类——双重标准" class="headerlink" title="LINUX系统的数据文件分类——双重标准"></a><strong>LINUX系统的数据文件分类——双重标准</strong></h5><p>共享的与独享的（shareable vs. unshareable）<br>数据与平台不相关，如/usr （共享） 数据是平台相关的，如配置数据/etc。变化的和静态的（variable vs. static）<br>相对非管理员用户而言的，没有更变的权限 （静态）</p>
<h5 id="Linux根文件系统逻辑组成"><a href="#Linux根文件系统逻辑组成" class="headerlink" title="Linux根文件系统逻辑组成"></a><strong>Linux根文件系统逻辑组成</strong></h5><p>（以具体目录表现逻辑功能）/ ——根目录（专用的静态的“根本所在”）/usr ——（共享的静态的）/var——（动态的共享的）/opt/home</p>
<h5 id="根目录必选组成目录"><a href="#根目录必选组成目录" class="headerlink" title="根目录必选组成目录"></a><strong>根目录必选组成目录</strong></h5><blockquote>
<p>/bin 基本工具或命令<br>/sbin 系统管理工具或命令<br>/etc 主机相关（Host-speciﬁc）的配置数据<br>/lib 基本共享库和内核模块<br>/dev 设备文件<br>/boot 引导程序<br>/root 管理员的工作目录<br>/mnt 系统管理员的临时挂接点<br>/tmp 系统级临时文件<br>/media 移动设备挂接点</p>
</blockquote>
<h5 id="usr-目录"><a href="#usr-目录" class="headerlink" title="/usr 目录"></a><strong>/usr 目录</strong></h5><p>/usr 目录是系统的一大组成部分，共享的静态的</p>
<p>静态：普通用户不可更改/usr下数据<br>共享：/usr下数据与主机平台不相关，代码独立于运行主机<br>/usr必选组成目录/usr/bin Most user commands<br>/usr/include Header ﬁles included by C programs<br>/usr/blib Libraries<br>/usr/local Local hierarchy (empty after main installation)<br>/usr/sbin Non-vital system binaries<br>/usr/share Architecture-independent data</p>
<h5 id="var目录"><a href="#var目录" class="headerlink" title="/var目录"></a><strong>/var目录</strong></h5><p>/var基本上是动态的和共享的（少量是主机相关的，如/var/log）。<br>/var保存大部分是程序运行期的动态生成数据</p>
]]></content>
    </entry>
    
  
  
</search>
