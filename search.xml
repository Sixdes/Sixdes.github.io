<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[LeetCode1541]]></title>
      <url>http://yoursite.com/2017/03/15/LeetCode%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>好久不碰了,小白求放过…😂</p>
<a id="more"></a>
<h1 id="LeetCode算法刷题过程"><a href="#LeetCode算法刷题过程" class="headerlink" title="LeetCode算法刷题过程"></a><strong>LeetCode算法刷题过程</strong></h1><h3 id="Tag-Arrays-和Hash-1-15"><a href="#Tag-Arrays-和Hash-1-15" class="headerlink" title="Tag: Arrays 和Hash (1,15)"></a><strong>Tag: <code>Arrays</code> 和<code>Hash</code> (1,15)</strong></h3><h4 id="1-twoSum-返回目标值索引"><a href="#1-twoSum-返回目标值索引" class="headerlink" title="1. twoSum 返回目标值索引"></a><strong>1. twoSum 返回目标值索引</strong></h4><blockquote>
<p>本题学习过程帮助我了解vector, unordered_map和map</p>
</blockquote>
<p>我的思路: 先对vector<int>num进行sort排序, 进而头尾相加, 小于target则头指针加一; 大于则只尾指针减一; 等于跳出循环</int></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec(nums);</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result ;</div><div class="line">    sort(nums.begin(), nums.end());</div><div class="line">    <span class="keyword">int</span> a,b,c=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=nums.size()<span class="number">-1</span>; i&lt;=j; i++,j--)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> temp = nums.at(i) + nums.at(j);</div><div class="line">        <span class="keyword">if</span>(temp &lt; target) &#123;j++;&#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(temp &gt; target)&#123;i--;&#125;</div><div class="line">        <span class="keyword">else</span> &#123;a=nums.at(i); b=nums.at(j);<span class="keyword">break</span>;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;vec.size();k++)&#123;</div><div class="line">        <span class="keyword">if</span>(c==<span class="number">2</span>) <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">if</span>(vec.at(k) == a) &#123;result.push_back(k);c++;</div><div class="line">            <span class="keyword">continue</span>;&#125;</div><div class="line">        <span class="keyword">if</span>(vec.at(k) == b) &#123;result.push_back(k);c++;</div><div class="line">            <span class="keyword">continue</span>;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>网上解答</em></p>
<p>Solution/*将n方复杂度的转换为linear, 主要是使用map追踪正确需要的数, 把需要的值存进map</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)&#123;</div><div class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</div><div class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</div><div class="line">    <span class="keyword">int</span> numToFind = target - nums[i];</div><div class="line">    <span class="keyword">if</span>(hash.find(numsToFind) != hash.end())&#123;</div><div class="line">      result.push_back(hash[numsToFind]);</div><div class="line">      result.push_back(i);</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    hash[nums[i]] = i;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####<strong>3.  15. 3Sum</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">报错</div><div class="line">Runtime Error Message: reference binding to null pointer of type &apos;struct value_type&apos;</div><div class="line">原因: 没有验证输入是否为空数组(向量)</div><div class="line">解决:方法里加入if判断</div></pre></td></tr></table></figure>
<p>我的思路:  参照第一题, 先外层遍历i, target=0-nums[i], 在按照第一题的方法去做</p>
<p><strong>问题</strong>: 内层时需要考虑不中间返回, 以及去重问题, 耽误了我的时间复杂度, 😭😭😭</p>
<p>开始      <strong>但是,超时了</strong>妈个叽</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; hash; <span class="comment">//便于追踪正确值, 两个的情况</span></div><div class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; skip; <span class="comment">//存放已测试的num[i],用于跳过</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</div><div class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; repeat;</div><div class="line">        <span class="keyword">if</span> (nums.size() &lt; <span class="number">3</span>)&#123;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size()<span class="number">-2</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (skip.find(nums[i]) != skip.end()) <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">int</span> target = <span class="number">0</span> - nums[i];</div><div class="line">            hash.clear();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++) &#123;</div><div class="line">                <span class="keyword">int</span> numToFind = target - nums[j];</div><div class="line">                <span class="keyword">if</span> (skip.find(nums[j]) != skip.end() || skip.find(numToFind) != skip.end()) <span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">if</span>(hash.find(nums[j]) != hash.end())&#123;</div><div class="line">                    <span class="keyword">if</span>(numToFind != nums[j]) <span class="keyword">continue</span>;</div><div class="line">                    <span class="keyword">if</span>(repeat.find(numToFind) != repeat.end()) <span class="keyword">continue</span>;</div><div class="line">                    repeat.insert(numToFind);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (hash.find(numToFind) != hash.end()) &#123;</div><div class="line">                        tmp.push_back(numToFind);</div><div class="line">                        tmp.push_back(nums[j]);</div><div class="line">                        tmp.push_back(nums[i]);</div><div class="line">                        result.push_back(tmp);</div><div class="line">                        tmp.clear();</div><div class="line">                    &#125;</div><div class="line">                    hash.insert(nums[j]);</div><div class="line">            &#125;</div><div class="line">            skip.insert(nums[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//改成能accepted, 然而复杂度不忍直视😂</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; hash; <span class="comment">//便于追踪正确值, 两个的情况</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp; </div><div class="line">        <span class="keyword">if</span> (nums.size() &lt; <span class="number">3</span>) &#123;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        sort(nums.begin(), nums.end());</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">2</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> ((i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i - <span class="number">1</span>]) || i == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">int</span> target = <span class="number">0</span> - nums[i];</div><div class="line">                hash.clear();</div><div class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</div><div class="line">                <span class="keyword">while</span>(j &lt; nums.size()) &#123;</div><div class="line">                   <span class="keyword">int</span> numToFind = target - nums[j];</div><div class="line">                    <span class="keyword">if</span>(hash.find(numToFind) != hash.end())&#123;</div><div class="line">                        tmp.push_back(numToFind);</div><div class="line">                        tmp.push_back(nums[j]);</div><div class="line">                        tmp.push_back(nums[i]);</div><div class="line">                        result.push_back(tmp);</div><div class="line">                        tmp.clear();</div><div class="line">                        <span class="keyword">while</span>(j &lt; nums.size()<span class="number">-1</span> &amp;&amp; nums[j] == nums[j+<span class="number">1</span>]) j++;</div><div class="line">                        j++;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> hash.insert(nums[j++]);</div><div class="line">               &#125;</div><div class="line">    <span class="comment">//            for(it = hash.begin(); it!=hash.end(); it++)&#123;cout&lt;&lt;*it&lt;&lt;"  ";&#125;</span></div><div class="line">            &#125;</div><div class="line">    <span class="comment">//        cout&lt;&lt;endl;</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>参照网上的答案更改过后:</p>
<p><strong>问题明白两点</strong>    </p>
<ul>
<li>排序,先对给定数组进行排序 </li>
<li>有时, while循环比for循环更好用  优势在于更好的控制每一次 i+1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</div><div class="line">    sort(nums.begin(), nums.end());</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</div><div class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i<span class="number">-1</span>]))&#123;</div><div class="line">            <span class="keyword">int</span> lo = i + <span class="number">1</span>, hi= nums.size() - <span class="number">1</span>, sum = <span class="number">0</span> - nums[i];</div><div class="line">            <span class="keyword">while</span> (lo &lt; hi)&#123;</div><div class="line">              <span class="comment">//第一次允许, 以后通过排序直接跳过可能的重复</span></div><div class="line">                <span class="keyword">if</span> (nums[lo] + nums[hi] ==  sum)&#123;</div><div class="line">                    tmp.push_back(nums[i]);</div><div class="line">                    tmp.push_back(nums[lo]);</div><div class="line">                    tmp.push_back(nums[hi]);</div><div class="line">                    res.push_back(tmp);</div><div class="line">                    tmp.clear();</div><div class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == nums[lo + <span class="number">1</span>]) 					lo++;</div><div class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == nums[hi - <span class="number">1</span>]) 					hi--;</div><div class="line">                    lo++; hi--;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[lo] + nums[hi] &lt; sum) lo++;</div><div class="line">                <span class="keyword">else</span> hi--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>char<em> p = “test”; 这个声明，声明了一个指针，而这个指针指向的是<em>*全局的const内存区</em></em>，const内存区当然不会让你想改就改的。</p>
<h4 id="541-Reverse-String-II"><a href="#541-Reverse-String-II" class="headerlink" title="541.Reverse String II"></a><strong>541.Reverse String II</strong></h4><p>问题描述：一串小写字符，分<k, k<s<2k,="" s="">2k几种情况，每2k个字符第k个逆转到开头,k范围[1, 10000]</k,></p>
<p><strong>小问题</strong>(是我理解的问题还是)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="built_in">string</span> <span class="title">reverseStr</span><span class="params">(String str, <span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>; left&lt;str.size; left+= <span class="number">2</span>*k)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=left,j=min(left+k<span class="number">-1</span>, <span class="keyword">int</span>(s.size()<span class="number">-1</span>)); i&lt;j; i++,j--)</div><div class="line">        &#123;</div><div class="line">          swap(s[i], s[j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[范数]]></title>
      <url>http://yoursite.com/2017/03/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%91%A8%E4%B9%8B%E8%8C%83%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>机器学习?(ノへ￣、)</p>
<a id="more"></a>
<h4 id="向量范数"><a href="#向量范数" class="headerlink" title="向量范数"></a><strong>向量范数</strong></h4><p>min∑(f(x)-y)^2+正则表达(范数解决过拟合问题)</p>
<ol>
<li><p>L0 特征选择, 非0元素稀疏, 缺点是难优化</p>
</li>
<li><p>L1  可以直接使得元素值为0从而容易稀疏</p>
</li>
<li><p>L2  岭回归  最小化L2范数,可以使得x的元素值都很小, 但都不是0</p>
<p>最小二乘L2范数优化, 凸优化方法</p>
<blockquote>
<p>优点: </p>
<p> 1) 改善”过拟合”overfitting—新样本表现很差(长发问题)</p>
<p>2) 利于优化  机器学习中有时候损失函数是非凸的, 例如: 神经网络, 梯度下降之类的方法遇见</p>
</blockquote>
</li>
</ol>
<h4 id="矩阵范数"><a href="#矩阵范数" class="headerlink" title="矩阵范数"></a><strong>矩阵范数</strong></h4><ol>
<li><p>1-范数  列范数最大 变成向量</p>
</li>
<li><p>2-范数  谱范数 难优化 求特征值</p>
</li>
<li><p>F-范数: (∑i=1,m∑j1,n aij^2)^1/2</p>
<p>最小化矩阵的f范数,会使得矩阵的每个元素都很小,近0</p>
<p>||A-B||F    A,B矩阵尽可能相同 应用字典学习</p>
</li>
<li><p>核范数—-矩阵奇异值的和  </p>
<p>最小化可以导致矩阵低秩  </p>
<p>矩阵的秩—-矩阵线性不相关的行数  去除冗余</p>
<p>不好求所以 近似 是核范数   </p>
<p>应用 推荐系统,低秩  奇异值分解   /鲁棒PCA 重构为低秩+噪声, 不在原始图像上降维</p>
</li>
<li><p>2,1范数 按列求2范数(平方开根)再求1范数, 整列(列向量)稀疏(全0)</p>
<p>Lasso 找出关键词  Group Lasso使一组为0,找出关键句子   Hierarchical Lasso找出关键段</p>
<p>应用:文本分类</p>
</li>
<li><p>1,2范数 按列1(每一列可能有好多0)再2(不稀疏保证了每一列不为0,进而保证了每一列中的每一行不可全为0,平方和开根不为0), 使得行内元素互斥, 行内有0元素但不可能全0</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python Scrapy]]></title>
      <url>http://yoursite.com/2016/12/15/Python%E5%AD%A6%E4%B9%A0%E4%B9%8BScrapy/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p><strong>简单介绍,之后加上知乎爬虫</strong>.</p>
<a id="more"></a>
<h4 id="概括"><a href="#概括" class="headerlink" title="概括"></a><strong>概括</strong></h4><p>框架优势——提供下载模块, 异步加载, 重点在于提取数据</p>
<p>response和request对象的区别</p>
<p>request是请求，即客服端发来的请求、<br>response是响应，是服务器做出的响应 </p>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h5><ol>
<li>创建一个Scrapy项目</li>
<li>定义提取的Item</li>
<li>编写爬取网站的 <a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/spiders.html#topics-spiders" target="_blank" rel="external">spider</a> 并提取 <a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/items.html#topics-items" target="_blank" rel="external">Item</a></li>
<li>编写 <a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/item-pipeline.html#topics-item-pipeline" target="_blank" rel="external">Item Pipeline</a> 来存储提取到的Item(即数据)</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建Scrapy项目, 注意更换pycharm中的Python源</span></div><div class="line">scrapy startproject tutorial</div><div class="line">scrapy.cfg: 项目的配置文件</div><div class="line">tutorial/: 该项目的python模块。之后您将在此加入代码。可更改</div><div class="line">tutorial/items.py: 项目中的item文件.</div><div class="line">tutorial/pipelines.py: 项目中的pipelines文件.</div><div class="line">tutorial/settings.py: 项目的设置文件.</div><div class="line">tutorial/spiders/: 放置spider代码的目录.</div></pre></td></tr></table></figure>
<h4 id="item部分"><a href="#item部分" class="headerlink" title="item部分"></a><strong>item部分</strong></h4><ol>
<li>item.py  Item容器就是将在网页中获取的数据结构化保存的数据结构，类似于Python中字典</li>
<li><strong>名字(title)，url(link)，以及网站的描述(desc)</strong></li>
<li><strong>Field</strong>一个包含了item所有声明的字段的字典，而不仅仅是获取到的字段。该字典的key是字段(field)的名字，值是 <a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/items.html#topics-items-declaring" target="_blank" rel="external">Item声明</a> 中使用到的 <a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/items.html#scrapy.item.Field" target="_blank" rel="external"><code>Field</code></a> 对象。<a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/items.html#scrapy.item.Field" target="_blank" rel="external"><code>Field</code></a> 对象指明了每个字段的元数据(metadata)。</li>
<li>爬取的主要目标就是从非结构性的数据源提取结构性数据</li>
</ol>
<h4 id="Spider部分"><a href="#Spider部分" class="headerlink" title="Spider部分"></a><strong>Spider部分</strong></h4><ol>
<li>Spider类继承自scrapy.Spider  主要负责爬取和解析数据和url, 具体实现函数大致为 start_requests 以及回调函数(负责接收response处理url, )</li>
<li>meta字典, Scrapy中传递额外数据的方法</li>
<li>unicode中的‘\xa0’字符在转换成gbk(汉字内码扩展规范)编码时会出现问题，gbk无法转换’\xa0’字符。<strong>\xa0是不间断空白符, <code>&amp;nbsp</code></strong>代表空白字符</li>
</ol>
<h4 id="Pipline部分"><a href="#Pipline部分" class="headerlink" title="Pipline部分"></a><strong>Pipline部分</strong></h4><p>当Item在Spider中被收集之后，它将会被传递到Item Pipeline，一些组件会按照一定的顺序执行对Item的处理。</p>
<p><strong>每个item pipeline组件(有时称之为“Item Pipeline”)是实现了简单方法的Python类</strong>。他们接收到Item并通过它执行一些行为，同时也决定此Item是否继续通过pipeline，或是被丢弃而不再进行处理。</p>
<p>以下是item pipeline的一些典型应用：</p>
<ul>
<li>清理HTML数据</li>
<li>验证爬取的数据(检查item包含某些字段)</li>
<li>查重(并丢弃)</li>
<li>将爬取结果保存到数据库中</li>
</ul>
<ol>
<li><p><code>process_item(item, spider)</code>每个item pipeline组件都需要调用该方法，这个方法必须返回一个 <a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/items.html#scrapy.item.Item" target="_blank" rel="external"><code>Item</code></a> (或任何继承类)对象， 或是抛出 <a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/exceptions.html#scrapy.exceptions.DropItem" target="_blank" rel="external"><code>DropItem</code></a> 异常，被丢弃的item将不会被之后的pipeline组件所处理。</p>
</li>
<li><p><code>open_spider(spider)</code></p>
<p>当spider被开启时，这个方法被调用。</p>
</li>
<li><p><code>close_spider(*spider*)</code></p>
<p>当spider被关闭时，这个方法被调用.</p>
<h4 id="将item写入JSON文件"><a href="#将item写入JSON文件" class="headerlink" title="将item写入JSON文件"></a><strong>将item写入JSON文件</strong></h4><p>pipeline将所有(从所有spider中)爬取到的item，存储到一个独立地 <code>items.jl</code> 文件，每行包含一个序列化为JSON格式的item:</p>
<p>​</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python 语法补充]]></title>
      <url>http://yoursite.com/2016/12/14/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E6%B3%95%E8%A1%A5%E5%85%85/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p><strong>一点零碎小知识</strong>.</p>
<a id="more"></a>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a><strong>打开文件</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    f = open(<span class="string">'xxxxx'</span>)</div><div class="line"><span class="keyword">except</span>:</div><div class="line">    print(<span class="string">'fail to open'</span>)</div><div class="line">    exit(<span class="number">-1</span>)</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    do something</div><div class="line"><span class="keyword">except</span>:</div><div class="line">    do something</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    f.close()//防止程序抛出异常最后不能关闭文件</div><div class="line">//另一个</div><div class="line"><span class="keyword">try</span>:</div><div class="line">	f = open(“file”, “r”)</div><div class="line"><span class="keyword">try</span>:</div><div class="line">	line = f.readline()</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">	f.close()</div><div class="line"><span class="keyword">except</span> IOError:</div><div class="line">	print(“bad”)</div></pre></td></tr></table></figure>
<h3 id="with-as-结构-确保异常可关闭"><a href="#with-as-结构-确保异常可关闭" class="headerlink" title="with ..  as ..结构  确保异常可关闭"></a><strong>with ..  as ..结构</strong>  <strong>确保异常可关闭</strong></h3><p>过程: with语句跳转<code>__enter__</code>函数, 返回值给as后的变量, 运行do sth , 最后跳转至<code>__exit__</code>函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">controlled_execution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></div><div class="line">        set things up</div><div class="line">        <span class="keyword">return</span> thing</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, type, value, traceback)</span>:</span></div><div class="line">        tear things down</div><div class="line">      </div><div class="line"><span class="keyword">with</span> open(<span class="string">'x.txt'</span>) <span class="keyword">as</span> f:</div><div class="line">    data = f.data()</div><div class="line">    do sth</div></pre></td></tr></table></figure>
<p><strong>exit</strong>除了用于tear things down，还可以进行异常的监控和处理，注意后几个参数。要跳过一个异常，只需要返回该函数True即可。下面的样例代码跳过了所有的TypeError，而让其他异常正常抛出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, type, value, traceback)</span>:</span></div><div class="line">    <span class="keyword">return</span> isinstance(value, TypeError)</div></pre></td></tr></table></figure>
<h3 id="迭代器-iterator-和生成器-generator"><a href="#迭代器-iterator-和生成器-generator" class="headerlink" title="迭代器 iterator 和生成器 generator"></a><strong>迭代器 iterator 和生成器 generator</strong></h3><p>实现迭代器协议, 有next方法的对象会前进到下一结果, 直到引发StopIteration结束, 在Python中有迭代器对象都可以使用for循环遍历, 好处是每次只从对象中读取一条数据，不会造成内存的过大开销(不是一次性加载到内存中)。</p>
<p>特点: yield</p>
<p>不像一般的函数生成值后会退出, 生成函数在生成值后会自动挂起并暂停它们的执行和状态, 它的本地变量将保存状态信息, 这些信息在函数恢复时会再度有效</p>
<p>可以简单地把列表生成式改成generator，也可以通过函数实现复杂逻辑的generator。工作原理，在<code>for</code>循环的过程中不断计算出下一个元素，并在适当的条件结束<code>for</code>循环。对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句，就是结束generator的指令，<code>for</code>循环随之结束。</p>
<p>包含yield语句的是生成器函数, 其执行流程如下 :</p>
<p>每次调用<code>next</code>时执行, 遇到<code>yield</code>停止, 下次再调用next时, 从yield停止处继续 .使用时直接调用for循环即可<code>for n in filb(5): print n</code>.</p>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a><strong>切片</strong></h3><p>a[start, end, step]带步进值的</p>
<p><strong>正序索引（0，i-1）倒序索引（-1，-i）</strong></p>
<p><code>step &gt; 0: start —&gt; end</code> ( 不含 end ) 从左往右, 相隔元素 step - 1 (索引值差 step ), 若 start 位于 end 右边, 返回空<br><code>step &lt; 0: start -&gt; end</code> (不含 end ) 从右到左, 相隔元素 step-1 (索引值差step ),若 start 位于 end 左边, 返回空<br>翻转字符串 <code>[::-1]</code> </p>
<h3 id="Python模块之BeautifulSoup及HTML解析器"><a href="#Python模块之BeautifulSoup及HTML解析器" class="headerlink" title="Python模块之BeautifulSoup及HTML解析器 "></a><strong>Python模块之BeautifulSoup及HTML解析器 </strong></h3><p>soup.title.name   title      soup.title.string  具体名字</p>
<p>所有HTML均是对象, 四种对象Tag(标签) , NavigableString(string) , BeautifulSoup(类似tag 但无name和atter属性), Comment</p>
<p><strong>find_all取出来是以列表形式存在,不用for循环无法继续find</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">解析器</th>
<th style="text-align:center">使用方法</th>
<th style="text-align:center">优势</th>
<th style="text-align:center">劣势</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Python标准库</td>
<td style="text-align:center">BeautifulSoup(markup, “html.parser”)</td>
<td style="text-align:center">Python的内置标准库执行速度适中文档容错能力强</td>
<td style="text-align:center">Python 2.7.3 or 3.2.2)前 的版本中文档容错能力差</td>
</tr>
<tr>
<td style="text-align:center">lxml HTML 解析器</td>
<td style="text-align:center">BeautifulSoup(markup, “lxml”)</td>
<td style="text-align:center">速度快文档容错能力强</td>
<td style="text-align:center">需要安装C语言库</td>
</tr>
<tr>
<td style="text-align:center">lxml XML 解析器</td>
<td style="text-align:center">BeautifulSoup(markup, [“lxml”, “xml”])BeautifulSoup(markup, “xml”)</td>
<td style="text-align:center">速度快唯一支持XML的解析器</td>
<td style="text-align:center">需要安装C语言库</td>
</tr>
<tr>
<td style="text-align:center">html5lib</td>
<td style="text-align:center">BeautifulSoup(markup, “html5lib”)</td>
<td style="text-align:center">最好的容错性以浏览器的方式解析文档生成HTML5格式的文档</td>
<td style="text-align:center">速度慢不依赖外部扩展</td>
</tr>
</tbody>
</table>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a><strong>回调函数</strong></h3><blockquote>
<p>回调函数就是一个通过<strong>函数指针</strong>调用的函数。如果你把函数的指针(地址)作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是<strong>在特定的事件或条件发生</strong>时由另外的一方调用的，用于<strong>对该事件或条件进行响应</strong>。</p>
</blockquote>
<p>软件模块之间总是存在一定接口, 调用方式上可分3类: </p>
<ul>
<li>同步调用(阻塞式调用,等待对方执行完毕才返回, 单向调用)</li>
<li>异步调用(类似消息或事件的机制——接口的服务在收到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）</li>
<li>回调(双向调用模式——回调函数被调用方在接口被调用的时候也会调用对方的接口)</li>
</ul>
<p>回调和异步调用的关系非常紧密，通常我们使用回调来实现<strong>异步消息的注册</strong>，通过异步调用来实现<strong>消息的通知</strong>。</p>
<p>回调常常是异调的基础</p>
<h3 id="json格式"><a href="#json格式" class="headerlink" title="json格式"></a><strong>json格式</strong></h3><p>dumps() 是将 dict 转化成 str 格式，loads() 是将 str 转化成 dict 格式。</p>
<p>dump 和 load 也是类似的功能，只是与文件操作结合起来了</p>
<p>简单说就是dump需要一个类似于文件指针的参数（并不是真的指针，可称之为类文件对象），可以与文件操作结合，也就是说可以将 dict 转成 str 然后存入文件中；而 dumps 直接给的是 str，也就是将字典转成str。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> json</div><div class="line">a =&#123;<span class="string">"name"</span>: <span class="string">"wang"</span>&#125;</div><div class="line">fp = open(<span class="string">'test.txt'</span>,<span class="string">'w'</span>)</div><div class="line">json.dump(a, fp)</div><div class="line">fp.close()</div></pre></td></tr></table></figure>
<h3 id="assert—断言"><a href="#assert—断言" class="headerlink" title="assert—断言"></a><strong>assert—断言</strong></h3><p>在没完善一个程序之前，我们不知道程序在哪里会出错，与其让它在运行时崩溃，不如在出现错误条件时就崩溃，这时候就需要 assert 断言的帮助. assert 断言语句为 raise-if-not，用来测试表示式，其返回值为假，就会触发异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#可为断言添加异常参数,用于解释 assert expression [, arguments]</span></div><div class="line"><span class="keyword">assert</span> len(lists) &gt;=<span class="number">5</span>,<span class="string">'列表元素个数小于5'</span></div><div class="line"><span class="keyword">assert</span> <span class="number">2</span>==<span class="number">1</span>,<span class="string">'2不等于1'</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[STL学习]]></title>
      <url>http://yoursite.com/2016/11/14/STL(Standard%C2%A0Template%C2%A0Library)%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>🙉🙉, 我要做好好读书的好巨婴, 恩!</p>
<a id="more"></a>
<h1 id="STL-Standard-Template-Library-学习"><a href="#STL-Standard-Template-Library-学习" class="headerlink" title="STL(Standard Template Library)学习"></a><strong>STL(Standard Template Library)学习</strong></h1><h2 id="读-lt-lt-Effective-STL-gt-gt"><a href="#读-lt-lt-Effective-STL-gt-gt" class="headerlink" title="读&lt;&lt;Effective STL&gt;&gt;"></a><strong>读&lt;<code>&lt;Effective STL&gt;</code>&gt;</strong></h2><h3 id="导论"><a href="#导论" class="headerlink" title="导论"></a><strong>导论</strong></h3><blockquote>
<p>导论:</p>
<p>本书中的”STL” —与<strong>迭代器</strong>合作的 c++ 标准库的一部分.包括标准容器(包括  string) , iostream 库</p>
</blockquote>
<h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a><strong>术语</strong></h4><p><strong>迭代器的类型:</strong></p>
<ul>
<li>输入迭代器(每个迭代位置只能被读一次的只读迭代器, 通常表现为istream_iterator )</li>
<li>输出迭代器(每个迭代位置只能被写一次的只写迭代器, 通常表现为ostream_iterator )</li>
<li>前向迭代器(有输入和输出迭代器的能力, 但可反复读或写一个位置,  不支持operator-, 所以可以高效地向前移动任意次数)  (单链表\散列可提供)  </li>
<li>双向迭代器(类似前向迭代器, 但后退可以像前进一样容易)(标准关联容器都提供)</li>
<li>随机访问迭代器(做双向迭代一切事情，但它们也提供“ 迭代算术” ，即，有一步向前或向后跳的能 力。vector、string 和deque 都提供随机访问迭代 。指进数组的指针可以作为数组的随机访问迭代 。)             </li>
</ul>
<p>STL包括五大类组件：算法 algorithm、容器、迭代器 iterator、函数对象、适配器</p>
<p>序列强调值的排序, 关联式强调值的关键字和索引</p>
<ul>
<li>标准STL序列容器: vector、string、deque和list</li>
<li>标准STL关联容器: set、multiset、map和multimap。</li>
<li>非标准序列容器 slist和 rope。</li>
<li>非标准关联容器 hash_set、hash_multiset、hash_map 和 hash_multimap。</li>
<li>几种标准非STL容器，包括数组、bitset、valarray、stack、queue和priority_queue。</li>
</ul>
<h3 id="the-first-仔细选择你的容器"><a href="#the-first-仔细选择你的容器" class="headerlink" title="the first: 仔细选择你的容器"></a><strong>the first: 仔细选择你的容器</strong></h3><h4 id="vector-list-deque选择"><a href="#vector-list-deque选择" class="headerlink" title="vector, list, deque选择"></a><strong>vector, list, deque选择</strong></h4><p>vector、list和deque提供给程序员不同的复杂度，因此应该这么用:vector是一种可以默认使用的序列类型(<strong>对尾部的插入和删除, 对数据的访问</strong>)，当很频繁地对<strong>序列中部</strong>进行插入和删除时应该用list，当大部分<strong>插入和删除发生在序列的头或尾</strong>时可以选择deque这种数据结构.</p>
<h4 id="STL容器的分类方法"><a href="#STL容器的分类方法" class="headerlink" title="STL容器的分类方法"></a><strong>STL容器的分类方法</strong></h4><ul>
<li><p>连续内存容器(基于array的容器)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">在一个或多个(动态分配)的内存块中保存它们的元素。如果一个新元素被插入或者已存元素被删除，其他在同一个内存块的元素就必须向上或者向下移动来为新元素提供空间或者填充原来被删除的元素所占的空间。这种移动影响了效率和异常安全.</div><div class="line">标准的连续内存容器是vector、string和deque。非标准的rope也是连续内存容器.</div></pre></td></tr></table></figure>
</li>
<li><p>基于节点的容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">在每个内存块(动态分配)中只保存一个元素。容器元素的插入或删除只影响指向节点的指针，而不是节点自己的内容。所以当有东西插入或删除时，元素值不需要移动。</div><div class="line">表现为链表的容器——比如 list 和 slist ——是基于节点的，所有的标准关联容器也是(它们的典型实现是平衡树)。</div><div class="line">非标准的散列容器使 用不同的基于节点的实现.</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[网络相关背景]]></title>
      <url>http://yoursite.com/2016/11/05/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E8%83%8C%E6%99%AF/</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<h3 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a><strong>相关名词</strong></h3><h4 id="网线和网卡"><a href="#网线和网卡" class="headerlink" title="网线和网卡"></a><strong>网线和网卡</strong></h4><p>网线：即双绞线(twisted pair，TP)，是一种综合布线工程中最常用的传输介质，<strong>传输信号</strong><br>网卡：网卡是工作在<strong>数据链路层</strong>的网络组件，是<strong>局域网</strong>中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。<strong>平台，发射和接收信号</strong><br>PS:现在大多数的笔记本电脑里内置了有线网卡和无线网卡，即<strong>以太网适配器</strong><br>有线网卡需要用网线连接后加入局域网，无线网卡可以通过无线传输来更便捷的接入局域网。</p>
<h4 id="IP地址-IPv4"><a href="#IP地址-IPv4" class="headerlink" title="IP地址(IPv4)"></a><strong>IP地址(IPv4)</strong></h4><p>4个8位二进制数表示的定位网络位置的方法，一般我们把它转换成<strong>4段十进制数字</strong></p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a><strong>子网掩码</strong></h4><p>也是32位二进制数，规则是前面必须是连续的1，表示网络位，后面为连续的0，表示主机位。255.255.255.224<br>子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。</p>
<h4 id="默认网关"><a href="#默认网关" class="headerlink" title="默认网关"></a><strong>默认网关</strong></h4><p>一个用于 TCP/IP 协议的配置项，是一个可直接到达的 IP 路由器的 IP 地址<br>配置默认网关可以在 IP 路由表中创建一个默认路径</p>
<h3 id="TCP-IP协议——网络通信的标准协议"><a href="#TCP-IP协议——网络通信的标准协议" class="headerlink" title="TCP/IP协议——网络通信的标准协议"></a><strong>TCP/IP协议——网络通信的标准协议</strong></h3><p>网络服务<a href="http://baike.baidu.com/link?url=zgUQnV0noG6bj70pn6uzjHcxkSjp-gIhMO04fMZ69yPL3D_WlCy2vDDlmCN2iwh0m-ifrm8thMwmv-olVoIJUK" target="_blank" rel="external">链接</a><br>服务器端口<a href="http://baike.baidu.com/link?url=Eod5R06EATtFkqc45akcT88sqNx6vD6UpZkz6HBtM6OPvGbxPHyvb03GZ7aTyrTqkIu_XDXPNH1mMp12N0VcA_#3_8" target="_blank" rel="external">链接</a></p>
<h4 id="解决物理接口问题"><a href="#解决物理接口问题" class="headerlink" title="解决物理接口问题"></a><strong>解决物理接口问题</strong></h4><blockquote>
<p>TCP/IP协议集成到操作系统的内核，相当于在操作系统中引入了一种新的输入/输出接口技术，<br>因为在TCP/IP协议中引入了一种称之为”Socket（套接字）”应用程序接口。<br>一台计算机就可以通过软件的方式与任何一台具有Socket接口的计算机进行通信</p>
</blockquote>
<h4 id="端口分类"><a href="#端口分类" class="headerlink" title="端口分类"></a><strong>端口分类</strong></h4><ul>
<li><h5 id="根据参考对象不同"><a href="#根据参考对象不同" class="headerlink" title="根据参考对象不同"></a><strong>根据参考对象不同</strong></h5><p>1）公认端口（Well Known Ports）：<strong>0到1023</strong>紧密绑定特定的服务，不可重定义<br>2）注册端口（Registered Ports）：<strong>1024到49151</strong>松散绑定于某些服务，<br>这些端口多数没有明确的定义服务对象，不同程序可根据实际需要自己定义<br>3）动态和/或私有端口（Dynamic and/or Private Ports）：<strong>9152到65535</strong></p>
</li>
<li><h5 id="根据所提供的服务方式的不同——两种通信协议"><a href="#根据所提供的服务方式的不同——两种通信协议" class="headerlink" title="根据所提供的服务方式的不同——两种通信协议"></a><strong>根据所提供的服务方式的不同——两种通信协议</strong></h5><p>TCP—–”连接方式”是一种直接与接收方进行的连接，发送信息以后，可以确认信息是否到达<br>UDP——“无连接方式”不是直接与接收方进行连接，只管把信息放在网上发出去，而不管信息是否到达，<br>1）TCP协议端口：<br>i. FTP—定义了文件传输协议，使用21端口。<br>ii. Telnet—用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上,通过这种端口可以提供一种基于DOS模式下的通信服务<br>iii. SMTP—–定义了简单邮件传送协议，很多邮件服务器都用的是这个协议，用于发送邮件。25端口<br>iv.POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Foxmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件<br>2）UDP协议端口：</p>
</li>
</ul>
<h4 id="网络服务、端口、协议"><a href="#网络服务、端口、协议" class="headerlink" title="网络服务、端口、协议"></a><strong>网络服务、端口、协议</strong></h4><p>TCP/IP协议定义了不同端口，用于支持不同的服务各种服务采用不同的端口提供不同的服务 比如：通常TCP/IP协议规定Web采用80号端口，FTP采用21号端口等，而邮件服务器是采用25号端口。通过不同端口，pc可以与外界进行互不干扰的通信.</p>
<p>与网络相关的Dos命令</p>
<p>ping命令——<strong>Ping空格IP地址</strong>也属于一个通信协议，<br>用来检查网络是否通畅或者网络连接速度的命令</p>
<h4 id="HTTP相关"><a href="#HTTP相关" class="headerlink" title="HTTP相关"></a><strong>HTTP相关</strong></h4><ul>
<li>http客户端发起请求, 创建端口.</li>
<li>http服务器在端口监听客户端请求</li>
<li>http服务器向客户端返回状态和内容</li>
<li>查看曾经浏览过的DNS缓存记录</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c++ map篇]]></title>
      <url>http://yoursite.com/2016/10/16/map%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><blockquote>
<p>c++11加入unordered_map, 类似map, 存储key-value值, </p>
<p>Map 键值对应容器, map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。</p>
</blockquote>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a><strong>基础</strong></h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><p><code>map&lt;string,   int&gt;   my_Map;</code></p>
<h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my_Map[<span class="string">'a'</span>] = <span class="number">1</span>;</div><div class="line">my_Map.insert(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::value_type(<span class="string">"b"</span>, <span class="number">2</span>));</div><div class="line">my_Map.insert(pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;(<span class="string">"c"</span>, <span class="number">3</span>))</div><div class="line">my_Map.insert(make_pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;(<span class="string">"d"</span>,<span class="number">4</span>));</div></pre></td></tr></table></figure>
<h4 id="查询和修改数据"><a href="#查询和修改数据" class="headerlink" title="查询和修改数据"></a><strong>查询和修改数据</strong></h4><p>(键本身是不能被修改的，除非删除)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = my_Map[<span class="string">"a"</span>];</div><div class="line">my_Map[<span class="string">"a"</span>] = i;</div><div class="line">MY_MAP::iterator my_Itr;</div><div class="line">my_Itr.find(<span class="string">"b"</span>);</div><div class="line"><span class="keyword">int</span> j = my_Itr-&gt;second;</div><div class="line">my_Itr-&gt;second = j;</div></pre></td></tr></table></figure>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a><strong>删除数据</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my_Map.erase(my_Itr);<span class="comment">//在迭代期间是不能被删除的，道理和foreach时不能删除元素一样。 </span></div><div class="line">my_Map.erase(<span class="string">"c"</span>)</div></pre></td></tr></table></figure>
<h4 id="迭代数据"><a href="#迭代数据" class="headerlink" title="迭代数据"></a><strong>迭代数据</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(my_Itr=my_Map.begin();my_Itr!=my_Map.end();++myItr)&#123;&#125;</div></pre></td></tr></table></figure>
<h4 id="other"><a href="#other" class="headerlink" title="other"></a><strong>other</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my_Map.size()        返回元素数目 </div><div class="line">my_Map.empty()       判断是否为空 </div><div class="line">my_Map.clear()       清空所有元素</div></pre></td></tr></table></figure>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a><strong>进阶</strong></h3><h4 id="关于hash-map介绍"><a href="#关于hash-map介绍" class="headerlink" title="关于hash_map介绍"></a><strong>关于hash_map介绍</strong></h4><p>map提供key-value的存储和查找功能, 并且实现的效率比较高; 100万条记录，最多也只要20次的string.compare的比较，就能找到你要找的记录;200万条记录事，也只要用21次的比较。</p>
<p>对于速度的追求使得hash_map诞生. hash_map基于hash table（哈希表)—<strong>哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；编码也比较容易.而代价仅仅是消耗比较多的内存。</strong>“直接定址”与“解决冲突”是哈希表的两大特点。 </p>
<p>插入: key—&gt;hash值—&gt;桶号—&gt;桶内存key和value</p>
<p>取值(查找): key—&gt;hash值—&gt;桶号—&gt;比较桶内key值是否等</p>
<p><code>if(myhash_map.find(key)) != myhash_map.end()</code> 表示查找key成功</p>
<h4 id="hash函数-和-比较函数"><a href="#hash函数-和-比较函数" class="headerlink" title="hash函数 和 比较函数"></a><strong>hash函数</strong> 和 <strong>比较函数</strong></h4><p>很多类型如int等是有默认的hash函数的, 但像string这种没有, 需要自定义.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*---例如---*/</span></div><div class="line"><span class="keyword">struct</span> str_hash&#123;</div><div class="line">  <span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)<span class="keyword">const</span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> __h = <span class="number">0</span>; </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span> ; i &lt; str.size() ; i ++) </div><div class="line">      __h = <span class="number">5</span>*__h + str[i]; </div><div class="line">    <span class="keyword">return</span> <span class="keyword">size_t</span>(__h); </div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//如果你希望利用系统定义的字符串hash函数</span></div><div class="line"><span class="keyword">struct</span> str_hash&#123;</div><div class="line">  <span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="built_in">string</span>&amp;str)<span class="keyword">const</span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">return</span> __stl_hash_string(str.c_str());</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>可迭代对象：对象里面包含<strong>iter()</strong>方法的实现，对象的iter函数经调用之后会返回一个迭代器，里面包含具体数据获取的实现。</li>
<li>迭代器：包含有next方法的实现，在正确范围内返回期待的数据以及超出范围后能够抛出StopIteration的错误停止迭代。</li>
</ul>
<h4 id="此次"><a href="#此次" class="headerlink" title="此次"></a><strong>此次</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">list</span></div><div class="line"><span class="built_in">string</span></div><div class="line">t = iter(<span class="built_in">string</span>);</div><div class="line">For tt in t</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c++ vector篇]]></title>
      <url>http://yoursite.com/2016/10/01/c++%E5%AD%A6%E4%B9%A0%E4%B9%8Bvector%E7%AF%87/</url>
      <content type="html"><![CDATA[<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><p>对比array , vetor 消耗更多内存交换管理以及有效增长存储能力</p>
<p>efficient      访问元素(array), 从 end 添加删除元素</p>
<p>worse    非end添加删除元素, </p>
<p>less consistent iterators 相对于lists 和 forward_lists</p>
<p>The container uses an allocator object to dynamically handle its storage needs.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">c++ vector里的allocator</div><div class="line">内存池分配器, 管理了一段内存, 允许在他管理的内存上分配内存, 便于清楚了解在哪分配\使用\释放内存</div><div class="line">有时候, 对内存分配会有特别的要求，比如同一个类型分在一起，或者有特别的优化算法。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>``` 随时自动调整自身的大小以便容下所要放入的元素</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### **声明及初始化**</div><div class="line"></div><div class="line">```c++</div><div class="line">vector &lt;int&gt;a;</div><div class="line">vector &lt;int&gt;a(10);</div><div class="line">vector &lt;int&gt;a(b);</div><div class="line">vector &lt;int&gt;a(b.begin(),b.begin()+3)</div><div class="line">int n=[1,2,3,4,5];</div><div class="line">vector &lt;int&gt;a(n, n+5);</div><div class="line">vector &lt;int&gt;a(&amp;n[1], &amp;n[4])   //n1-n4范围</div></pre></td></tr></table></figure>
<h4 id="输入及访问"><a href="#输入及访问" class="headerlink" title="输入及访问"></a><strong>输入及访问</strong></h4><h4 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器 iterator"></a><strong>迭代器 iterator</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;:: iterator t;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t= vec.begin(); t != vec.end(); t++)&#123;</div><div class="line">  <span class="built_in">cout</span>&lt;&lt; *t &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="删除vector的内存空洞"><a href="#删除vector的内存空洞" class="headerlink" title="删除vector的内存空洞"></a><strong>删除vector的内存空洞</strong></h4><ul>
<li><p>erase()函数，只能删除内容，不能改变容量大小；</p>
<p>erase成员函数，它删除了itVect迭代器指向的元素，并且返回要被删除的itVect之后的迭代器，迭代器相当于一个智能指针。</p>
</li>
<li><p>clear()函数，只能清空内容，不能改变容量大小</p>
<p>vector容器删除不自动释放内存，那么它存在内存泄露？？？不是的，vector在析构函数的时候，对内存进行了释放。</p>
</li>
<li><p>如果要想在删除内容的同时释放内存，那么你可以选择<strong>deque</strong>容器。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>(v).swap(v);将v的内存空洞清除</div><div class="line"><span class="built_in">vector</span>().swap(v);清空vec</div></pre></td></tr></table></figure>
<p>vector的元素不仅仅可以是int,double,string,还可以是<strong>结构体</strong>，但是要注意：结构体要定义为全局的，否则会出错。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac Linux文件系统]]></title>
      <url>http://yoursite.com/2016/07/15/mac%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<h3 id="mac-文件系统"><a href="#mac-文件系统" class="headerlink" title="mac 文件系统"></a><strong>mac 文件系统</strong></h3><p>隐藏<br>cmd中ls /</p>
<h4 id="符合unix传统的目录"><a href="#符合unix传统的目录" class="headerlink" title="符合unix传统的目录"></a><strong>符合unix传统的目录</strong></h4><p>/bin 传统unix命令的存放目录，如ls，rm，mv等。<br>/sbin 传统unix管理类命令存放目录，如fdisk，ifconfig等等。<br>/usr 第三方程序安装目录。<br>/usr/bin, /usr/sbin, /usr/lib，其中/usr/lib目录中存放了共享库（动态链接库）.<br>/etc. 标准unix系统配置文件存放目录，如用户密码文件/etc/passwd。此目录实际为指向/private/etc的链接。<br>/dev 设备文件存放目录，如何代表硬盘的/dev/disk0。<br>/tmp 临时文件存放目录，其权限为所有人任意读写。此目录实际为指向/private/tmp的链接。<br>/var 存放经常变化的文件，如日志文件。此目录实际为指向/private/var的链接。</p>
<h4 id="os-x特有的目录"><a href="#os-x特有的目录" class="headerlink" title="os x特有的目录"></a><strong>os x特有的目录</strong></h4><p>/Applications 应用程序目录，默认所有的GUI应用程序都安装在这里；<br>/Library 系统的数据文件、帮助文件、文档等等；<br>/Network 网络节点存放目录；<br>/System 他只包含一个名为Library的目录，这个子目录中存放了系统的绝大部分组件，如各种framework，以及内核模块，字体文件等等。<br>/Users 存放用户的个人资料和配置。每个用户有自己的单独目录。<br>/Volumes 文件系统挂载点存放目录。<br>/cores 内核转储文件存放目录。当一个进程崩溃时，如果系统允许则会产生转储文件。<br>/private 里面的子目录存放了/tmp, /var, /etc等链接目录的目标目录。</p>
<p>OS X发生崩溃和不能启动的概率实在是太低了，就算是系统出现问题，由于用户目录和系统目录是彼此独立的，所以也容易找回。<br>所以通常情况下，用户直接把资料存放在自己的用户目录中</p>
<h3 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h3><p>形式表现上一体——所有数据目录均为根目录下的子目录<br>实质——多个不同的<strong>【逻辑主体】</strong>（为了实现不同的逻辑功能）组合在一起</p>
<h4 id="文件系统结构标准"><a href="#文件系统结构标准" class="headerlink" title="文件系统结构标准"></a><strong>文件系统结构标准</strong></h4><h5 id="LINUX系统的数据文件分类——双重标准"><a href="#LINUX系统的数据文件分类——双重标准" class="headerlink" title="LINUX系统的数据文件分类——双重标准"></a><strong>LINUX系统的数据文件分类——双重标准</strong></h5><p>共享的与独享的（shareable vs. unshareable）<br>数据与平台不相关，如/usr （共享） 数据是平台相关的，如配置数据/etc。变化的和静态的（variable vs. static）<br>相对非管理员用户而言的，没有更变的权限 （静态）</p>
<h5 id="Linux根文件系统逻辑组成"><a href="#Linux根文件系统逻辑组成" class="headerlink" title="Linux根文件系统逻辑组成"></a><strong>Linux根文件系统逻辑组成</strong></h5><p>（以具体目录表现逻辑功能）/ ——根目录（专用的静态的“根本所在”）/usr ——（共享的静态的）/var——（动态的共享的）/opt/home</p>
<h5 id="根目录必选组成目录"><a href="#根目录必选组成目录" class="headerlink" title="根目录必选组成目录"></a><strong>根目录必选组成目录</strong></h5><blockquote>
<p>/bin 基本工具或命令<br>/sbin 系统管理工具或命令<br>/etc 主机相关（Host-speciﬁc）的配置数据<br>/lib 基本共享库和内核模块<br>/dev 设备文件<br>/boot 引导程序<br>/root 管理员的工作目录<br>/mnt 系统管理员的临时挂接点<br>/tmp 系统级临时文件<br>/media 移动设备挂接点</p>
</blockquote>
<h5 id="usr-目录"><a href="#usr-目录" class="headerlink" title="/usr 目录"></a><strong>/usr 目录</strong></h5><p>/usr 目录是系统的一大组成部分，共享的静态的</p>
<p>静态：普通用户不可更改/usr下数据<br>共享：/usr下数据与主机平台不相关，代码独立于运行主机<br>/usr必选组成目录/usr/bin Most user commands<br>/usr/include Header ﬁles included by C programs<br>/usr/blib Libraries<br>/usr/local Local hierarchy (empty after main installation)<br>/usr/sbin Non-vital system binaries<br>/usr/share Architecture-independent data</p>
<h5 id="var目录"><a href="#var目录" class="headerlink" title="/var目录"></a><strong>/var目录</strong></h5><p>/var基本上是动态的和共享的（少量是主机相关的，如/var/log）。<br>/var保存大部分是程序运行期的动态生成数据</p>
]]></content>
    </entry>
    
  
  
</search>
